#!/usr/bin/env bash

# This script provides shortcuts for common ddev, shopware and other tools commands.
#
# Author: Andre Witte
#
# Description: dDEV shortening tools
# Usage: dev [OPTIONS] [PARAMETERS]
# Version: 1.3.3
# https://github.com/akaw/dev-cli-tools/
#
# shellcheck disable=SC2034,SC2168,SC2317

# Default Configuration
VERSION="1.3.3"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT:-orbstack}"
BACKUP_DIR="${BACKUP_DIR:-.project/backups}"
DB_EXPORT_FILE="${DB_EXPORT_FILE:-.project/db.sql.gz}"
DEFAULT_PHP_VERSION="${DEFAULT_PHP_VERSION:-8.2}"
DEFAULT_NODE_VERSION="${DEFAULT_NODE_VERSION:-20}"
DEFAULT_MYSQL_VERSION="${DEFAULT_MYSQL_VERSION:-8.0}"
LOG_FILE="${LOG_FILE:-dev.log}"
PREFERRED_EDITOR="${PREFERRED_EDITOR:-}"  # Empty default means no editor will be launched
CONFIG_FILE="${CONFIG_FILE:-$HOME/.dev-cli-tools.conf}"

OS=$(uname -s)

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

# Define script directory
SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

# Log level
log_level=1

# Logging configuration
LOG_FILE="${SCRIPT_DIR}/${LOG_FILE}"
LOG_LEVEL="${LOG_LEVEL:-INFO}" # Use LOG_LEVEL from environment or set to INFO

# Extended color definitions
declare -A COLORS=(
    [RESET]='\033[0m'
    [BOLD]='\033[1m'
    [DIM]='\033[2m'
    [ITALIC]='\033[3m'
    [DEBUG]='\033[0;36m'     # Cyan
    [INFO]='\033[0;32m'      # Green
    [WARN]='\033[0;33m'      # Yellow
    [ERROR]='\033[0;31m'     # Red
    [TIMESTAMP]='\033[0;90m' # Light gray
)

# Enhanced logging function
log() {
    local level=$1
    local message=$2
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"

    # Check if logging is enabled for this level
    [[ $level == "DEBUG" && $LOG_LEVEL != "DEBUG" ]] && return

    # Formatted output
    local output="${COLORS[TIMESTAMP]}${timestamp}${COLORS[RESET]} "
    output+="${COLORS[BOLD]}${COLORS[$level]}${level}${COLORS[RESET]} "
    output+="${message}"

    # Console output with formatting
    echo -e "$output"

    # File output without formatting
    echo "[${timestamp}] ${level}: ${message}" >>"${LOG_FILE}"
}

# Specific logging functions
debug() { log "DEBUG" "$1"; }
info() { log "INFO" "$1"; }
warn() { log "WARN" "$1"; }
error() { log "ERROR" "$1" >&2; }

# Replace old die() function
die() {
    error "$1"
    exit "${2:-1}"
}

# Display usage information
usage() {
    cat <<EOF
$(basename "${BASH_SOURCE[0]}") - Development Command Line Tools v${VERSION}

USAGE:
    $(basename "${BASH_SOURCE[0]}") [OPTION] COMMAND [ARGS]

OPTIONS:
    -h,  --help          Show this help
    -v,  --version       Show version
         --no-color      Disable colored output
         --no-deprecations  Suppress deprecation warnings
    -vv, --verbose       Verbose output

CONFIGURATION:
    setup                Run configuration wizard
    You can customize settings by running 'dev setup' or by editing:
    $CONFIG_FILE
    Configuration options include:
    - DOCKER_ENVIRONMENT: orbstack or docker
    - PREFERRED_EDITOR: code, phpstorm, etc.
    - DEFAULT_PHP_VERSION: 8.2, 8.1, etc.
    - DEFAULT_NODE_VERSION: 20, 18, etc.
    - LOG_LEVEL: INFO, DEBUG

PROJECT:
    u,   up              Start project
    d,   down            Stop project
    r,   restart         Restart project
    st,  status          Show project status
    o,   open            Open in browser
    s,   ssh             Connect via SSH
    init                 Initialize project

DATABASE:
    e,   export [file]   Export database (.project/db.sql.gz)
    i,   import [file]   Import database
    seq, sequelace       Start Sequel Ace
    da:mi                Run database migrations
    da:mi:all            Run all database migrations

DEVELOPMENT:
    x,   xdebug          Enable/disable xdebug (on|off)
    t,   test            Run tests [options]
    l,   logs            Show logs
    m,   mail            Start mail server
    dr,  debug:router    Show routing information

COMPOSER:
    c,   composer        Run composer command
    cup, update          Update dependencies
    cin, install         Install dependencies
    cre, require         Add package [pkg]
    crm, remove          Remove package [pkg]
    cda                  Update autoloader
    src, prefer-source   Reinstall package with source

SHOPWARE:
    b | build [comp]          Build components (js|admin|store)
    ba | build:administration Build administration
    bs | build:storefront     Build storefront
    bj | build:js             Build JavaScript
    w | watch [comp]          Watch components
    cc | cache:clear          Clear cache
    cd | cache:delete         Delete cache files
    mc | messenger:consume    Run messenger consumer
    pl | plugin:list          List plugins
    plre | plugin:refresh     Refresh plugins
    plac | plugin:activate    Activate plugin
    plde | plugin:deactivate  Deactivate plugin
    plin | plugin:install     Install plugin
    plun | plugin:uninstall   Uninstall plugin
    pu | plup | pl:up | plugin:update      Update plugin

Examples:
    dev        Start development environment
    dev u      Start project
    dev ci     Composer Install
    dev new    Create new project
    dev ba     bin/build-administration
    dev x on   Enable xdebug
EOF
    exit 0
}

# Simple versioning and message output
version() {
    echo -e "dev-cli-tools ${VERSION}\nhttps://github.com/akaw/dev-cli-tools/"
    exit 0
}

# Cleanup function to handle script termination
cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    # Stop all running processes
    jobs -p | xargs -r kill
    # Remove temporary files if they exist
    if [ -n "${TEMP_DIR-}" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
}

# Simplified color output
setup_colors() {
    NOFORMAT='\033[0m'
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
}

# Simple message output
msg() {
    echo "$1"
}

# Default function to start the development environment
# This function is called when no arguments are provided
default() {
    ensure_docker_environment
    # Check if DDEV project exists and start it
    if ddev describe >/dev/null 2>&1; then
        ensure_ddev_project
        ddev describe
        ddev sequelace
        ddev launch
    else
        warn "No DDEV project found in current directory."
        warn "Use 'ddev config' to initialize a new project or change to a project directory."
    fi
    # Open editor if configured
    if [[ -n "$PREFERRED_EDITOR" ]]; then
        debug "Opening project in $PREFERRED_EDITOR"
        $PREFERRED_EDITOR .
    fi
}

# Function to upgrade the script
upgrade() {
    local script_path="${BASH_SOURCE[0]}"
    info "Checking for updates..."
    # Check current version against latest version first
    local latest_version
    if ! latest_version=$(curl -s -m 5 "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev" | grep -m 1 "^VERSION=" | cut -d'"' -f2); then
        error "Could not check for updates. Please check your internet connection."
        return 1
    fi
    if [[ "$latest_version" == "$VERSION" ]]; then
        info "You already have the latest version ($VERSION)."
        return 0
    fi
    info "New version found: $latest_version (current: $VERSION)"
    info "Downloading update..."

    # Create backup
    cp "$script_path" "${script_path}.backup"
        # Remove update marker to force version check on next run
    rm -f "/tmp/dev_update_check_$(date +%Y%m%d)" 2>/dev/null
    if curl -o "$script_path" "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev"; then
        chmod +x "$script_path"
        info "Update successful!"
        # Get the new version directly from the script
        VERSION=$(grep -m 1 "^VERSION=" "$script_path" | cut -d'"' -f2)
        info "New version: ${VERSION}"
        info "Please restart your shell or run 'hash -r' to clear command cache."
    else
        error "Update failed. Restoring backup..."
        mv "${script_path}.backup" "$script_path"
        return 1
    fi

    rm -f "${script_path}.backup"
    exit 0
}

# Function to check if a file exists
check_file_exists() {
    local file_path="$1"
    if [[ ! -f "$file_path" ]]; then
        die "File not found: $file_path"
    fi
}

# Check service status based on environment
check_service_status() {
    local env=$1
    debug "Checking service status for environment: $env"

    case "$env" in
    "orbstack")
        if [[ "$OS" == "Darwin" ]]; then
            # First check OrbStack process/socket existence
            if pgrep -f "OrbStack" >/dev/null ||
                launchctl list | grep -q "com.orbstack.OrbStack" ||
                [[ -S "$HOME/.orbstack/run/docker.sock" ]]; then
                # Additionally verify Docker is operational by running a simple command
                if docker info >/dev/null 2>&1; then
                    debug "OrbStack is running and Docker is operational"
                    return 0
                else
                    debug "OrbStack process detected but Docker is not operational"
                    return 1
                fi
            fi
            debug "OrbStack is not running"
            return 1
        else
            debug "Checking OrbStack service via pgrep"
            if pgrep -f "OrbStack" >/dev/null && docker info >/dev/null 2>&1; then
                debug "OrbStack is running (Linux) and Docker is operational"
                return 0
            fi
            return 1
        fi
        ;;
    "docker")
        if [[ "$OS" == "Darwin" ]]; then
            debug "Checking Docker Desktop service via launchctl"
            if launchctl list | grep -q "com.docker.docker"; then
                # Verify Docker is actually operational
                if docker info >/dev/null 2>&1; then
                    debug "Docker Desktop is running and operational"
                    return 0
                else
                    debug "Docker Desktop process detected but not operational"
                    return 1
                fi
            fi
            return 1
        else
            debug "Checking Docker service via systemctl"
            if systemctl is-active --quiet "docker"; then
                if docker info >/dev/null 2>&1; then
                    debug "Docker service is running and operational"
                    return 0
                else
                    debug "Docker service detected but not operational"
                    return 1
                fi
            fi
            return 1
        fi
        ;;
    *)
        debug "Unknown environment: $env"
        return 1
        ;;
    esac
}

# Check if a service is running
check_service_running() {
    local service_type=$1
    local service_name=$2

    case "$service_type" in
    "launchctl")
        launchctl list | grep -q "$service_name"
        return $?
        ;;
    "pgrep")
        pgrep -x "$service_name" >/dev/null
        return $?
        ;;
    "systemctl")
        systemctl is-active --quiet "$service_name"
        return $?
        ;;
    *)
        return 1
        ;;
    esac
}

# Start a service based on OS and environment
start_service() {
    local env=$1
    local service=$2

    debug "Attempting to start $service ($env, $OS)"

    case "$OS" in
    "Darwin")
        debug "Starting $service with 'open' on macOS"
        open -ga "$service"
        ;;
    "Linux")
        debug "Starting $service on Linux"
        if [[ "$env" == "orbstack" ]]; then
            debug "Using orbstack start command"
            orbstack start
        else
            debug "Using systemctl for Docker"
            sudo systemctl start "$service"
        fi
        ;;
    *)
        die "Unsupported operating system: $OS"
        ;;
    esac

    local max_attempts=30
    local attempt=1

    debug "Waiting up to ${max_attempts}s for $service to start and become operational"

    while [ $attempt -le $max_attempts ]; do
        if check_service_status "$env"; then
            info "$service is ready and operational (after ${attempt}s)"
            return 0
        fi
        debug "Waiting for $service to become operational (attempt $attempt of $max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done

    die "$service could not be started or is not operational (timeout after $((max_attempts*2))s). Please start $service manually."
}

# Function to start Docker environment only if needed
ensure_docker_environment() {
    # Skip docker checks in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping Docker environment check"
        return 0
    fi
    # Declare variable first, then assign value
    local temp_marker
    temp_marker="/tmp/dev_docker_verified_$(date +%Y%m%d)"
    local marker_status=""

    # Always check Docker first if ALWAYS_CHECK_DOCKER is set
    if [[ "${ALWAYS_CHECK_DOCKER:-}" == "true" ]]; then
        debug "ALWAYS_CHECK_DOCKER is set, forcing Docker check"
    # Otherwise check for marker
    elif [[ -f "$temp_marker" ]]; then
        marker_status=$(cat "$temp_marker" 2>/dev/null)

        # Skip verification if marker indicates Docker is running
        if [[ "$marker_status" == "running" ]]; then
            # Quick verify with docker command to be sure
            if docker info >/dev/null 2>&1; then
                debug "Docker environment verified as running (cached), skipping full check"
                return 0
            else
                debug "Docker appears to be down, will restart automatically"
            fi
        else
            debug "Docker was previously down, will try to start it"
        fi
    fi

    debug "Verifying Docker environment..."

    # Check if DDEV is installed
    if ! command -v ddev &>/dev/null; then
        die "ddev is not installed. Please install ddev first."
    fi

    if [[ -z "${DOCKER_ENVIRONMENT:-}" ]]; then
        die "DOCKER_ENVIRONMENT is not set. Please set it to 'orbstack' or 'docker'"
    fi

    debug "Checking Docker environment: $DOCKER_ENVIRONMENT"

    # Validate Docker environment early
    if [[ "$DOCKER_ENVIRONMENT" != "orbstack" && "$DOCKER_ENVIRONMENT" != "docker" ]]; then
        die "Invalid Docker environment: $DOCKER_ENVIRONMENT. Supported values are: orbstack, docker"
    fi

    local docker_running=false

    case "${DOCKER_ENVIRONMENT}" in
    "orbstack")
        if check_service_status "orbstack"; then
            debug "OrbStack is already running and operational"
            docker_running=true
        else
            debug "Starting OrbStack automatically..."
            if ! start_service "orbstack" "/Applications/OrbStack.app"; then
                warn "Failed to automatically start OrbStack. Please start it manually."
                warn "If OrbStack is already running, it might not be fully initialized or is in a broken state."
                warn "Try restarting OrbStack manually and then run the command again."

                # Mark as not running in the marker file
                echo "not_running" > "$temp_marker"
                exit 1
            fi

            # Successfully started
            docker_running=true

            # Wait for OrbStack to stabilize
            debug "Waiting briefly for OrbStack to fully stabilize..."
            sleep 5
        fi
        ;;
    "docker")
        if check_service_status "docker"; then
            debug "Docker is already running and operational"
            docker_running=true
        else
            if [[ "$OS" == "Darwin" ]]; then
                debug "Starting Docker Desktop automatically..."
                if ! start_service "docker" "Docker"; then
                    warn "Failed to automatically start Docker Desktop. Please start it manually."

                    # Mark as not running in the marker file
                    echo "not_running" > "$temp_marker"
                    exit 1
                fi
            else
                debug "Starting Docker service automatically..."
                if ! start_service "docker" "docker"; then
                    warn "Failed to automatically start Docker service. Please start it manually."

                    # Mark as not running in the marker file
                    echo "not_running" > "$temp_marker"
                    exit 1
                fi
            fi

            # Successfully started
            docker_running=true

            # Wait for Docker to stabilize
            debug "Waiting briefly for Docker to fully stabilize..."
            sleep 5
        fi
        ;;
    esac

    # Double-check Docker is actually running before updating marker
    if [[ "$docker_running" == "true" ]] && docker info >/dev/null 2>&1; then
        echo "running" > "$temp_marker"
        debug "Docker environment verified as running and marker updated"
    else
        echo "not_running" > "$temp_marker"
        if [[ "$docker_running" == "true" ]]; then
            warn "Docker appeared to start but is not operational, check your Docker/OrbStack installation"
        else
            debug "Docker environment verified as not running and marker updated"
        fi
    fi

    # Final verification - make sure Docker is actually running
    if ! docker info >/dev/null 2>&1; then
        die "Docker environment verification failed. Please start Docker/OrbStack manually and try again."
    fi

    return 0
}

# Create project structure and initialize configuration
create_project_structure() {
    local project_type=$1
    local project_name=${2:-$(basename "$PWD")}

    debug "Creating project structure for: $project_type ($project_name)"

    # Create basic project structure
    mkdir -p .project/{backups,config,scripts}

    # Create common configuration
    cat >.project/config/common.env <<EOL
APP_ENV=dev
APP_DEBUG=1
COMPOSER_MEMORY_LIMIT=-1
EOL

    # Project specific configurations
    case "$project_type" in
    "symfony")
        debug "Setting up Symfony project configuration"
        cat >.project/config/ddev.yaml <<EOL
name: $project_name
type: php
docroot: public
php_version: "${DEFAULT_PHP_VERSION}"
nodejs_version: "${DEFAULT_NODE_VERSION}"
mysql_version: "${DEFAULT_MYSQL_VERSION}"
webserver_type: nginx-fpm
web_environment:
- DATABASE_URL=mysql://db:db@db:3306/db
- MAILER_DSN=smtp://localhost:1025
- APP_ENV=dev
- APP_DEBUG=1

hooks:
  post-start:
    - exec: composer install
    - exec: bin/console cache:clear
EOL
        ;;
    "shopware")
        debug "Setting up Shopware project configuration"
        cat >.project/config/ddev.yaml <<EOL
name: $project_name
type: shopware6
docroot: shopware/public
php_version: "${DEFAULT_PHP_VERSION}"
nodejs_version: "${DEFAULT_NODE_VERSION}"
mysql_version: "${DEFAULT_MYSQL_VERSION}"
webserver_type: apache-fpm
web_environment:
- DATABASE_URL=mysql://db:db@db:3306/db
- MAILER_DSN=smtp://localhost:1025?encryption=&auth_mode=
- APP_URL=\${DDEV_PRIMARY_URL}
- APP_ENV=dev
- APP_DEBUG=1
- LOCK_DSN=flock

hooks:
  post-start:
    - exec: composer install
    - exec: bin/console cache:clear
    - exec: bin/build-js.sh
EOL

        # Create Shopware specific scripts
        cat >.project/scripts/build-all.sh <<EOL
#!/bin/bash
bin/build-js.sh
bin/build-storefront.sh
bin/build-administration.sh
EOL
        chmod +x .project/scripts/build-all.sh
        ;;
    *)
        die "Unsupported project type: $project_type"
        ;;
    esac

    # Create gitignore if it doesn't exist
    if [[ ! -f ".gitignore" ]]; then
        cat >.gitignore <<EOL
/.project/backups/
/.env.local
/vendor/
/var/
/node_modules/
*.log
.DS_Store
EOL
    fi

    debug "Project structure created successfully"
    return 0
}

# Setup build tools for project
setup_build_tools() {
    local project_type=$1

    debug "Setting up build tools for: $project_type"

    case "$project_type" in
    "symfony")
        debug "Installing Symfony build dependencies"
        ddev composer require --dev symfony/webpack-encore
        ddev npm install
        ;;

    "shopware")
        debug "Installing Shopware build dependencies"
        ddev npm clean-install
        ddev npm run build
        ;;
    esac

    # Create common build scripts
    mkdir -p .project/scripts

    # Create build script
    cat >.project/scripts/build.sh <<EOL
#!/bin/bash
set -e

echo "Building project assets..."
if [ -f "bin/build-js.sh" ]; then
    bin/build-js.sh
fi

if [ -f "bin/build-storefront.sh" ]; then
    bin/build-storefront.sh
fi

if [ -f "bin/build-administration.sh" ]; then
    bin/build-administration.sh
fi

if [ -f "node_modules/.bin/encore" ]; then
    node_modules/.bin/encore production
fi

echo "Build completed successfully"
EOL
    chmod +x .project/scripts/build.sh

    debug "Build tools setup completed"
    return 0
}

# Load configuration from file
load_config() {
    # Skip if we're in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping config loading"
        return 0
    fi

    if [[ -f "$CONFIG_FILE" && -r "$CONFIG_FILE" ]]; then
        debug "Loading configuration from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        return 0
    else
        debug "No configuration file found at $CONFIG_FILE or file not readable"
        return 1
    fi
}

# Save configuration to file
save_config() {
    debug "Saving configuration to $CONFIG_FILE"

    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Clear existing file
    true > "$CONFIG_FILE"

    # Write configuration values
    echo "# DEV CLI Tools Configuration" > "$CONFIG_FILE"
    echo "# Generated on $(date)" >> "$CONFIG_FILE"
    echo "" >> "$CONFIG_FILE"

    [[ -n "$DOCKER_ENVIRONMENT" ]] && echo "export DOCKER_ENVIRONMENT=\"$DOCKER_ENVIRONMENT\"" >> "$CONFIG_FILE"
    [[ -n "$PREFERRED_EDITOR" ]] && echo "export PREFERRED_EDITOR=\"$PREFERRED_EDITOR\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_PHP_VERSION" ]] && echo "export DEFAULT_PHP_VERSION=\"$DEFAULT_PHP_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_NODE_VERSION" ]] && echo "export DEFAULT_NODE_VERSION=\"$DEFAULT_NODE_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_MYSQL_VERSION" ]] && echo "export DEFAULT_MYSQL_VERSION=\"$DEFAULT_MYSQL_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$LOG_LEVEL" ]] && echo "export LOG_LEVEL=\"$LOG_LEVEL\"" >> "$CONFIG_FILE"

    info "Configuration saved to $CONFIG_FILE"
}

# Setup configuration
setup_config() {
    info "Welcome to DEV CLI Tools Setup"
    info "This will configure your preferences for DEV CLI Tools"
    echo ""

    # Docker environment
    echo "Select your preferred Docker environment:"
    echo "1) OrbStack (recommended for macOS)"
    echo "2) Docker Desktop"
    echo "3) Native Docker (Linux)"
    echo ""
    read -r -p "Enter your choice [1-3, default: 1]: " docker_choice

    case "${docker_choice:-1}" in
        1) DOCKER_ENVIRONMENT="orbstack" ;;
        2) DOCKER_ENVIRONMENT="docker" ;;
        3) DOCKER_ENVIRONMENT="docker" ;;
        *) DOCKER_ENVIRONMENT="orbstack" ;;
    esac

    echo ""
    echo "Docker environment set to: $DOCKER_ENVIRONMENT"
    echo ""

    # Preferred editor
    echo "Select your preferred code editor:"
    echo "1) No default editor"
    echo "2) Visual Studio Code (code)"
    echo "3) PhpStorm (phpstorm)"
    echo "4) Sublime Text (subl)"
    echo "5) Custom (specify command)"
    echo ""
    read -r -p "Enter your choice [1-5, default: 1]: " editor_choice

    case "${editor_choice:-1}" in
        1) PREFERRED_EDITOR="" ;;
        2) PREFERRED_EDITOR="code" ;;
        3) PREFERRED_EDITOR="phpstorm" ;;
        4) PREFERRED_EDITOR="subl" ;;
        5)
            read -r -p "Enter the command to open your editor: " custom_editor
            PREFERRED_EDITOR="$custom_editor"
            ;;
        *) PREFERRED_EDITOR="" ;;
    esac

    if [[ -n "$PREFERRED_EDITOR" ]]; then
        echo "Preferred editor set to: $PREFERRED_EDITOR"
    else
        echo "No default editor set"
    fi
    echo ""

    # Default PHP version
    read -r -p "Enter default PHP version [default: 8.2]: " php_version
    DEFAULT_PHP_VERSION="${php_version:-8.2}"
    echo "Default PHP version set to: $DEFAULT_PHP_VERSION"
    echo ""

    # Default Node.js version
    read -r -p "Enter default Node.js version [default: 20]: " node_version
    DEFAULT_NODE_VERSION="${node_version:-20}"
    echo "Default Node.js version set to: $DEFAULT_NODE_VERSION"
    echo ""

    # Default MySQL version
    read -r -p "Enter default MySQL version [default: 8.0]: " mysql_version
    DEFAULT_MYSQL_VERSION="${mysql_version:-8.0}"
    echo "Default MySQL version set to: $DEFAULT_MYSQL_VERSION"
    echo ""

    # Log level
    echo "Select log level:"
    echo "1) INFO (standard level, recommended)"
    echo "2) DEBUG (verbose output for troubleshooting)"
    echo ""
    read -r -p "Enter your choice [1-2, default: 1]: " log_level_choice

    case "${log_level_choice:-1}" in
        1) LOG_LEVEL="INFO" ;;
        2) LOG_LEVEL="DEBUG" ;;
        *) LOG_LEVEL="INFO" ;;
    esac

    echo "Log level set to: $LOG_LEVEL"
    echo ""

    # Save configuration
    save_config

    info "Setup complete! Your preferences have been saved."
    info "You can change these settings any time by running 'dev setup' again."
    echo ""
}

# Function to check for updates
check_for_updates() {
    # Skip update check in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping update check"
        return 0
    fi

    # Skip if we've already checked recently (within 24 hours)
    local update_marker
    update_marker="/tmp/dev_update_check_$(date +%Y%m%d)"
    if [[ -f "$update_marker" ]]; then
        debug "Update already checked today, skipping check"
        return 0
    fi

    # Create marker to avoid checking again today
    touch "$update_marker"

    debug "Checking for updates..."

    # Try to get the latest version from GitHub
    local latest_version
    if ! latest_version=$(curl -s -m 3 "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev" | grep -m 1 "^VERSION=" | cut -d'"' -f2); then
        debug "Could not check for updates, network issue?"
        return 1
    fi

    debug "Current version: $VERSION, Latest version: $latest_version"

    # Compare versions (simple string comparison, assumes semantic versioning)
    if [[ "$latest_version" != "$VERSION" && -n "$latest_version" ]]; then
        info "A new version ($latest_version) of dev-cli-tools is available!"
        info "You're currently using version $VERSION."
        info "Run 'dev upgrade' to update to the latest version."
        echo ""
    fi

    return 0
}

# Parse command-line parameters
parse_params() {
    # Initialize all command flags
    init_command_flags

    # Get the command (first argument)
    local command="${1-}"
    [[ -z "$command" ]] && return 0
    shift || true

    case "$command" in
    u | up | start)
        debug "Starting project..."
        start=1
        ;;

    d | down | stop)
        debug "Stopping project..."
        down=1
        ;;

    r | restart)
        debug "Restarting project..."
        restart=1
        ;;

    st | sta | stat | status | info)
        debug "Showing project status..."
        status=1
        ;;

    o | launch)
        debug "Opening in browser..."
        launch=1
        launchparam="${1-}"
        [[ -n "$launchparam" ]] && shift
        ;;

    s | ssh)
        debug "Connecting via SSH..."
        ssh=1
        ;;

    # Database commands
    e | export)
        debug "Exporting database..."
        exportdb=1
        exportdbparam="${1-.project/db.sql.gz}"
        [[ -n "$exportdbparam" ]] && shift
        ;;

    i | import)
        debug "Importing database..."
        importdb=1
        importdbparam="${1-.project/db.sql.gz}"
        [[ -n "$importdbparam" ]] && shift
        ;;

    se | seq | sequelace)
        debug "Starting Sequel Ace..."
        sequelace=1
        ;;

    dami | da:mi | database:migrate)
        debug "Running database migrations..."
        console=1
        consoleparam="database:migrate ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    damiall | da:mi:all | database:migrate:all)
        debug "Running all database migrations..."
        console=1
        consoleparam="database:migrate --all"
        ;;

    # Development commands
    x | xdebug)
        debug "Toggling xdebug..."
        xdebug=1
        xdebugparam="${1-on}"
        [[ -n "${1-}" ]] && shift
        ;;

    t | test)
        debug "Running tests..."
        test=1
        testparam="${1-}"
        [[ -n "$testparam" ]] && shift
        ;;

    l | logs)
        debug "Showing logs..."
        logs=1
        ;;

    m | ma | mail)
        debug "Starting mail server..."
        mail=1
        ;;

    dr | de:ro | debug:router)
        debug "Running debug:router..."
        console=1
        consoleparam="debug:router"
        ;;

    # Composer commands
    c | com | composer)
        debug "Running composer command..."
        composer=1
        composerparam="${1-}"
        [[ -n "$composerparam" ]] && shift
        ;;

    cup | update)
        debug "Updating dependencies..."
        composer=1
        composerparam="update"
        ;;

    cin | install)
        debug "Installing dependencies..."
        composer=1
        composerparam="install"
        ;;

    cre | require)
        debug "Adding package..."
        require=1
        requireparam="${1-}"
        [[ -n "$requireparam" ]] && shift
        ;;

    crm | remove)
        debug "Removing package..."
        remove=1
        removeparam="${1-}"
        [[ -n "$removeparam" ]] && shift
        ;;

    ca | cda | dump-autoload)
        debug "Updating autoloader..."
        composer=1
        composerparam="dump-autoload"
        ;;

    src | source | prefer-source)
        debug "Setting prefer-source..."
        prefersource=1
        prefersourceparam="${1-}"
        [[ -n "$prefersourceparam" ]] && shift
        ;;

    # Shopware commands
    b | build)
        debug "Building components..."
        build=1
        buildparam="${1-}"
        [[ -n "$buildparam" ]] && shift
        ;;

    ba | build:administration)
        debug "Building administration..."
        build=1
        buildparam="administration"
        ;;

    bs | build:storefront)
        debug "Building storefront..."
        build=1
        buildparam="storefront"
        ;;

    bj | build:js | all)
        debug "Building JavaScript..."
        build=1
        buildparam="js"
        ;;

    w | watch)
        debug "Watching components..."
        watch=1
        watchparam="${1-}"
        [[ -n "$watchparam" ]] && shift
        ;;

    wa | wa:ad | watch:administration)
        debug "Watching administration..."
        watch=1
        watchparam="administration"
        ;;

    ws | wa:st | watch:storefront)
        debug "Watching storefront..."
        watch=1
        watchparam="storefront"
        ;;

    cd | cade | ca:de | cache:delete)
        debug "Deleting cache..."
        deletecache=1
        ;;

    cc | cacl | ca:cl | cache:clear)
        debug "Clearing cache..."
        console=1
        consoleparam="cache:clear"
        ;;

    mc | meco | me:co | messenger:consume)
        debug "Starting messenger consumer..."
        console=1
        consoleparam="messenger:consume"
        ;;

    # Plugin commands
    plre | pl:re | plugin:refresh)
        debug "Refreshing plugins..."
        console=1
        consoleparam="plugin:refresh"
        ;;

    pl | pli | plli | pl:li | plugin:list)
        debug "Listing plugins..."
        console=1
        consoleparam="plugin:list"
        ;;

    plac | pl:ac | plugin:activate)
        debug "Activating plugin..."
        console=1
        consoleparam="plugin:activate ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    plin | pl:in | plugin:install)
        debug "Installing plugin..."
        console=1
        consoleparam="plugin:install ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    plun | pl:un | plugin:uninstall)
        debug "Uninstalling plugin..."
        console=1
        consoleparam="plugin:uninstall ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    pu | plup | pl:up | plugin:update)
        debug "Updating plugin..."
        console=1
        consoleparam="plugin:update ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    plde | pl:de | plugin:deactivate)
        debug "Deactivating plugin..."
        console=1
        consoleparam="plugin:deactivate ${1-}"
        [[ -n "${1-}" ]] && shift
        ;;

    # Project commands
    n | new)
        debug "Creating new project..."
        new=1
        newparam="${1-}"
        if [[ -z "$newparam" ]]; then
            read -r -p "Project type (symfony|shopware): " newparam
        else
            shift
        fi

        # Normalize project type
        case "$newparam" in
        symfony | sy | sym)
            newparam="symfony"
            ;;
        shopware | sw | sh | sho | shop)
            newparam="shopware"
            ;;
        *)
            die "Unknown project type: $newparam. Use symfony or shopware"
            ;;
        esac
        ;;

    init)
        debug "Initializing project..."
        init=1
        ;;

    bk | backup)
        debug "Creating backup..."
        backup=1
        ;;

    rs | restore)
        debug "Restoring from backup..."
        restore=1
        restoreparam="${1-}"
        [[ -n "$restoreparam" ]] && shift
        ;;

    upgrade)
        debug "Upgrading script..."
        upgrade
        ;;

    setup)
        debug "Setting up configuration..."
        setup_config
        exit 0
        ;;

    *)
        debug "Executing command in container: $command $*"
        ddev exec "$command" "$@"
        ;;
    esac

    return 0
}

# Initialize command flags
init_command_flags() {
    # Project commands
    new=0
    newparam=""
    start=0
    down=0
    restart=0
    status=0
    init=0
    ssh=0

    # Database commands
    exportdb=0
    exportdbparam=""
    importdb=0
    importdbparam=""
    sequelace=0

    # Development commands
    xdebug=0
    xdebugparam=""
    test=0
    testparam=""
    logs=0
    mail=0
    deletecache=0

    # Console commands
    console=0
    consoleparam=""
    no_deprecations=0
    verbose=0

    # Build commands
    build=0
    buildparam=""
    watch=0
    watchparam=""

    # Composer commands
    composer=0
    composerparam=""
    require=0
    requireparam=""
    remove=0
    removeparam=""

    # Package commands
    packages=0
    packagesparam=""
    prefersource=0
    prefersourceparam=""

    # Launch commands
    launch=0
    launchparam=""

    # Backup commands
    backup=0
    restore=0
    restoreparam=""

    # System flags
    version=0
    lint=0
    NO_COLOR=0
}

# Main execution
main() {
    # Setup colors first
    setup_colors

    # Handle global options
    while [[ "${1-}" =~ ^- ]]; do
        case "${1-}" in
        --no-color)
            NO_COLOR=1
            shift
            ;;
        --no-deprecations)
            no_deprecations=1
            shift
            ;;
        -vv | --verbose)
            verbose=1
            shift
            ;;
        -v | --version)
            version
            exit 0
            ;;
        -h | --help)
            usage
            exit 0
            ;;
        *)
            break
            ;;
        esac
    done

    # Load configuration if available
    load_config || debug "No existing configuration found, using defaults"

    # Skip configuration setup in test mode or for special commands
    if [[ ! "${DEV_TEST_MODE:-}" == "true" ]] && [[ ! -f "$CONFIG_FILE" ]]; then
        info "This appears to be your first time running DEV CLI Tools."
        info "Would you like to set up your preferences now?"
        read -r -p "Run setup wizard? [Y/n]: " setup_response
        case "${setup_response:-y}" in
            [Yy]*)
                setup_config
                ;;
            *)
                info "You can run setup any time with 'dev setup'"
                ;;
        esac
    fi

    # Enable debug logging if set
    if [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
        debug "Debug mode enabled"
        debug "Operating system: $OS"
        debug "Docker environment: ${DOCKER_ENVIRONMENT:-not set}"
    fi

    # Check for updates
    check_for_updates

    # No arguments provided
    if [ $# -eq 0 ]; then
        default
        exit 0
    fi

    # Parse and execute commands
    parse_params "$@"
    execute_commands

    exit 0
}

# Execute commands based on flags
execute_commands() {
    # Execute console commands
    if [[ $console == 1 ]]; then
        # Only verify Docker when actually needed
        ensure_docker_environment

        # Use the new helper function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        # Special handling for cache:clear command to avoid unnecessary restarts
        if [[ $consoleparam == "cache:clear" ]]; then
            debug "Running cache:clear command directly..."

            local console_flags=""
            [[ $verbose == 1 ]] && console_flags+=" -v"

            # Add deprecation handling for Shopware console commands via environment variable
            if [[ -f "bin/console" && -d "vendor/shopware" ]]; then
                debug "Automatically suppressing deprecation warnings for Shopware via SYMFONY_DEPRECATIONS_HELPER"
                ddev exec SYMFONY_DEPRECATIONS_HELPER=weak bin/console cache:clear "$console_flags"
            else
                ddev exec bin/console cache:clear "$console_flags"
            fi
            return 0
        fi

        debug "Executing console command: $consoleparam"
        local console_flags=""
        local env_vars=""

        # Add deprecation handling for Shopware console commands via environment variable
        if [[ -f "bin/console" && -d "vendor/shopware" ]]; then
            env_vars="SYMFONY_DEPRECATIONS_HELPER=weak"
            debug "Automatically suppressing deprecation warnings for Shopware via SYMFONY_DEPRECATIONS_HELPER"
        fi

        # Still respect explicit flag if set, but use it only for logging purposes
        [[ $no_deprecations == 1 ]] && debug "Deprecation warnings suppressed via user flag"
        [[ $verbose == 1 ]] && console_flags+=" -v"

        if [[ -n "$env_vars" ]]; then
            ddev exec "$env_vars" bin/console "$console_flags" "$consoleparam"
        else
            ddev exec bin/console "$console_flags" "$consoleparam"
        fi
    fi

    # Run composer commands
    if [[ $composer == 1 ]]; then
        ensure_docker_environment

        # Use the new helper function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Running composer command: $composerparam"
        ddev composer "$composerparam"
    fi

    # Handle package requirements
    if [[ $require == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Adding package: $requireparam"
        if [[ $prefersource == 1 ]]; then
            ddev composer require "$requireparam" --prefer-source
        else
            ddev composer require "$requireparam"
        fi
    fi

    # Handle package removal
    if [[ $remove == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Removing package: $removeparam"
        ddev composer remove "$removeparam"
    fi

    # Build shopware components
    if [[ $build == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Building components: $buildparam"
        case "$buildparam" in
        "storefront" | "store" | "s")
            ddev exec bin/build-storefront.sh
            ;;
        "administration" | "admin" | "a")
            ddev exec bin/build-administration.sh
            ;;
        "js" | "javascript" | "j")
            ddev exec bin/build-js.sh
            ;;
        *)
            warn "Unknown build component: $buildparam"
            ;;
        esac
    fi

    # Watch components
    if [[ $watch == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Watching components: $watchparam"
        case "$watchparam" in
        "storefront" | "store" | "s")
            ddev exec bin/watch-storefront.sh
            ;;
        "administration" | "admin" | "a")
            ddev exec bin/watch-administration.sh
            ;;
        *)
            warn "Unknown watch component: $watchparam"
            ;;
        esac
    fi

    # Database operations
    if [[ $exportdb == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Exporting database to: $exportdbparam"
        ddev export-db -f "$exportdbparam"
    fi

    if [[ $importdb == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Importing database from: $importdbparam"
        check_file_exists "$importdbparam"
        ddev import-db -f "$importdbparam"
    fi

    # Project operations
    if [[ $start == 1 ]]; then
        ensure_docker_environment
        debug "Starting project..."
        ddev start
        ddev describe
    fi

    if [[ $down == 1 ]]; then
        ensure_docker_environment
        debug "Stopping project..."
        ddev stop
    fi

    if [[ $restart == 1 ]]; then
        ensure_docker_environment
        debug "Restarting project..."
        ddev restart
        ddev describe
    fi

    if [[ $status == 1 ]]; then
        ensure_docker_environment
        debug "Showing project status..."
        ddev describe
    fi

    # Direct command execution
    if [[ $ssh == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Opening SSH connection..."
        ddev ssh
    fi

    if [[ $sequelace == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Starting Sequel Ace..."
        ddev sequelace
    fi

    if [[ $launch == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        if [[ -n "$launchparam" ]]; then
            debug "Opening specific URL: $launchparam"
            ddev launch "$launchparam"
        else
            debug "Opening default project URL..."
            ddev launch
        fi
    fi

    # Cache operations
    if [[ $deletecache == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Deleting cache files..."
        ddev exec rm -rf var/cache/dev*
        ddev exec rm -rf var/cache/prod*
    fi

    # Testing
    if [[ $test == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Running tests: ${testparam-}"
        ddev exec php bin/phpunit "${testparam-}"
    fi

    # Initialize project
    if [[ $init == 1 ]]; then
        ensure_docker_environment
        debug "Initializing project..."
        read -r -p "Initialize DEV Environment? This will overwrite db and .env.local (y/n)?" choice
        case "$choice" in
        y | Y)
            info "Starting initialization..."
            check_file_exists ".project/init.sql.gz"
            check_file_exists ".project/env.ddev"
            ddev exec cp .env.ddev .env.local
            ddev start
            ddev import-db -f .project/init.sql.gz
            ddev describe
            ;;
        *)
            info "Initialization cancelled"
            ;;
        esac
    fi

    # Backup and restore
    if [[ $backup == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Creating backup..."
        mkdir -p "$BACKUP_DIR"
        local backup_file
        backup_file="${BACKUP_DIR}/backup-$(date '+%Y-%m-%d-%H-%M-%S').tar.gz"
        ddev exec tar -czf "$backup_file" .
        info "Backup created: $backup_file"
    fi

    if [[ $restore == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Restoring from backup: ${restoreparam-backup.tar.gz}"
        check_file_exists "${restoreparam-backup.tar.gz}"
        ddev exec tar -xzf "${restoreparam-backup.tar.gz}"
        info "Project restored from: ${restoreparam-backup.tar.gz}"
    fi

    # Mail server
    if [[ $mail == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Starting mail server..."
        ddev mailhog
    fi

    # Package handling
    if [[ $packages == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Processing packages..."
        process_packages
    fi

    # New project creation
    if [[ $new == 1 ]]; then
        ensure_docker_environment
        debug "Creating new project of type: $newparam"
        # Rest of new project creation code
    fi

    # Remove unnecessary variables
    unset RED GREEN sequelace logs down xdebug ssh start deletecache restart status \
        update install require requireparam prune upgrade poweroff version lint \
        launch launchparam remove removeparam mail NO_COLOR args

    return 0
}

# Function to process packages and create symlinks
process_packages() {
    debug "Processing packages..."
    local base_dir="./"
    local vendor_dir="$base_dir/vendor"
    local plugins_dir="$base_dir/custom/plugins"

    # Create plugins directory if it doesn't exist
    mkdir -p "$plugins_dir"

    # Process store packages
    debug "Processing store packages..."
    if ! find "$vendor_dir/store.shopware.com" -name "composer.json" -type f -maxdepth 2 2>/dev/null | while read -r store_composer_file; do
        local path
        local link_name
        local link_path

        path=$(dirname "$store_composer_file" | sed "s|$vendor_dir/||")
        link_name=$(create_package_name "$path")
        link_path="$plugins_dir/$link_name"

        if [[ $packagesparam == "true" ]]; then
            debug "Creating symlink for $link_name"
            [ -L "$link_path" ] && unlink "$link_path"
            [ -d "$link_path" ] && rmdir "$link_path"
            ln -s "../../vendor/$path" "$link_path"
            info "Created symlink for $link_name"
        else
            echo "$link_name"
        fi
    done; then
        warn "No store packages found or error processing packages"
    fi
}

# Function to create a standardized package name
create_package_name() {
    if [[ $# -ne 1 ]]; then
        die "Usage: create_package_name <path>"
    fi

    local path="$1"
    local vendor
    local name

    vendor=$(echo "$path" | cut -d'/' -f1)
    name=$(echo "$path" | cut -d'/' -f2)

    # Capitalize first letter of vendor
    vendor="${vendor^}"

    # Convert kebab-case to PascalCase
    name=$(echo "$name" | sed -e 's/-/ /g' -e 's/\b\(.\)/\u\1/g' -e 's/ //g')

    echo "$vendor$name"
}

# Function to check if a container is running and start it if necessary
check_and_ensure_running_container() {
    # Skip container checks in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping container status check"
        return 0
    fi

    # First check if we're even in a valid project directory
    if [ ! -d ".ddev" ] || [ ! -f ".ddev/config.yaml" ]; then
        warn "This command requires a DDEV project, but none was found in the current directory."
        info "Please change to a directory with a DDEV project or create one with 'ddev config'."
        info "Alternatively, you can create a new project (Symfony or Shopware) with 'dev new'."
        return 1
    fi

    # Get project name to check container status
    local project_name
    project_name=$(grep "name:" .ddev/config.yaml | head -n1 | awk '{print $2}')
    debug "Found DDEV project: $project_name"
    
    debug "Checking container status for project: $project_name"
    
    # APPROACH 1: Try direct docker container check first (most reliable)
    debug "Checking for running Docker container..."
    local container_running=false
    if docker ps --format "{{.Names}}" 2>/dev/null | grep -q "ddev-${project_name}-web"; then
        debug "FOUND RUNNING CONTAINER: Docker reports container 'ddev-${project_name}-web' is running"
        container_running=true
    else
        debug "Docker container check: No running container for project found"
    fi
    
    # APPROACH 2: Try ddev status JSON output as backup
    if [[ "$container_running" != "true" ]]; then
        debug "Trying DDEV JSON status check as alternative..."
        
        # Check if we can get JSON output from ddev
        local json_output
        if json_output=$(ddev describe --json-output 2>/dev/null); then
            debug "Successfully got JSON output from DDEV"
            
            # If jq is available, use it for proper parsing
            if command -v jq >/dev/null 2>&1; then
                local json_status
                json_status=$(echo "$json_output" | jq -r '.[0].status' 2>/dev/null)
                debug "JSON status: '$json_status'"
                
                if [[ "$json_status" == "running" || "$json_status" == "Running" ]]; then
                    debug "JSON check confirms container is running (status: $json_status)"
                    container_running=true
                fi
            else
                # Fallback for systems without jq - crude grep for running status
                if echo "$json_output" | grep -q '"status":"running"' || 
                   echo "$json_output" | grep -q '"status":"Running"'; then
                    debug "Simple JSON grep confirms container is running"
                    container_running=true
                fi
            fi
        else
            debug "Failed to get JSON output from DDEV"
        fi
    fi
    
    # Final decision based on our checks
    if [[ "$container_running" == "true" ]]; then
        debug "FINAL DETERMINATION: Container IS running - no restart needed"
        return 0
    else
        debug "FINAL DETERMINATION: Container is NOT running - will start it now"
        debug "Starting the container..."
        if ! ddev start; then
            error "Failed to start DDEV project. Please check for errors and try again."
            return 1
        fi
        debug "Container started successfully"
        return 0
    fi
}

# Function to ensure DDEV project is running
ensure_ddev_project() {
    # Skip project checks in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping DDEV project check"
        return 0
    fi

    debug "Ensuring DDEV project is running..."

    # Use the new helper function - call directly and return its status
    check_and_ensure_running_container
    return $?
}

# Eine Hilfsfunktion für die Fehlermeldung, um Code-Duplizierung zu vermeiden
check_ddev_project() {
    debug "Calling check_ddev_project..."

    # Use the new helper function - call directly and return its status
    check_and_ensure_running_container
    return $?
}

# Start execution
main "$@"
