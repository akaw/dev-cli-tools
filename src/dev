#!/usr/bin/env bash

# This script provides shortcuts for common ddev, shopware and other tools commands.
#
# Author: Andre Witte
#
# Description: dDEV shortening tools
# Usage: dev [OPTIONS] [PARAMETERS]
# Version: 1.4.3
# https://github.com/akaw/dev-cli-tools/
#
# shellcheck disable=SC2034,SC2168,SC2317

# Default Configuration
VERSION="1.4.3"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT:-orbstack}"
BACKUP_DIR="${BACKUP_DIR:-.project/backups}"
DB_EXPORT_FILE="${DB_EXPORT_FILE:-.project/db.sql.gz}"
DEFAULT_PHP_VERSION="${DEFAULT_PHP_VERSION:-8.2}"
DEFAULT_NODE_VERSION="${DEFAULT_NODE_VERSION:-20}"
DEFAULT_MYSQL_VERSION="${DEFAULT_MYSQL_VERSION:-8.0}"
LOG_FILE="${LOG_FILE:-dev.log}"
PREFERRED_EDITOR="${PREFERRED_EDITOR:-}"  # Empty default means no editor will be launched
CONFIG_FILE="${CONFIG_FILE:-$HOME/.config/.dev-cli-tools.conf}"

OS=$(uname -s)

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

# Define script directory
SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

# Log level
log_level=1

# Performance optimization: Container status cache
declare -A CONTAINER_STATUS_CACHE
declare -A PROJECT_NAME_CACHE
CACHE_TTL=30  # Cache TTL in seconds

# Command registry for improved parsing
declare -A COMMAND_REGISTRY
declare -A COMMAND_ALIASES
declare -A COMMAND_DESCRIPTIONS
declare -A COMMAND_PARAMS

# Logging configuration
LOG_FILE="${SCRIPT_DIR}/${LOG_FILE}"
LOG_LEVEL="${LOG_LEVEL:-INFO}" # Use LOG_LEVEL from environment or set to INFO

# Extended color definitions
declare -A COLORS=(
    [RESET]='\033[0m'
    [BOLD]='\033[1m'
    [DIM]='\033[2m'
    [ITALIC]='\033[3m'
    [DEBUG]='\033[0;36m'     # Cyan
    [INFO]='\033[0;32m'      # Green
    [WARN]='\033[0;33m'      # Yellow
    [ERROR]='\033[0;31m'     # Red
    [TIMESTAMP]='\033[0;90m' # Light gray
)

# Enhanced logging function
log() {
    local level=$1
    local message=$2
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"

    # Check if logging is enabled for this level
    [[ $level == "DEBUG" && $LOG_LEVEL != "DEBUG" ]] && return

    # Formatted outpu
    local output="${COLORS[TIMESTAMP]}${timestamp}${COLORS[RESET]} "
    output+="${COLORS[BOLD]}${COLORS[$level]}${level}${COLORS[RESET]} "
    output+="${message}"

    # Console output with formatting
    echo -e "$output"

    # File output without formatting
    echo "[${timestamp}] ${level}: ${message}" >>"${LOG_FILE}"
}

# Specific logging functions
debug() { log "DEBUG" "$1"; }
info() { log "INFO" "$1"; }
warn() { log "WARN" "$1"; }
error() { log "ERROR" "$1" >&2; }

# Enhanced error handling functions
die() {
    error "$1"
    cleanup_on_error
    exit "${2:-1}"
}

# Consistent error handling with context
handle_error() {
    local error_msg="$1"
    local context="${2:-unknown}"
    local exit_code="${3:-1}"
    
    error "[$context] $error_msg"
    debug "Error occurred in context: $context"
    
    # Log error details for debugging
    if [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
        debug "Call stack: ${FUNCNAME[*]}"
        debug "Error code: $exit_code"
    fi
    
    return "$exit_code"
}

# Safe command execution with error handling
safe_execute() {
    local cmd="$1"
    local context="${2:-command execution}"
    local error_msg="${3:-Command failed}"
    
    debug "Executing: $cmd"
    
    if ! eval "$cmd" 2>/dev/null; then
        handle_error "$error_msg: $cmd" "$context"
        return 1
    fi
    
    debug "Command executed successfully: $cmd"
    return 0
}

# Validate input parameters
validate_param() {
    local param="$1"
    local param_name="${2:-parameter}"
    local validation_type="${3:-non_empty}"
    
    case "$validation_type" in
        "non_empty")
            if [[ -z "$param" ]]; then
                handle_error "Missing required parameter: $param_name" "parameter validation"
                return 1
            fi
            ;;
        "file_exists")
            if [[ ! -f "$param" ]]; then
                handle_error "File not found: $param" "file validation"
                return 1
            fi
            ;;
        "dir_exists")
            if [[ ! -d "$param" ]]; then
                handle_error "Directory not found: $param" "directory validation"
                return 1
            fi
            ;;
        "version_format")
            if [[ ! "$param" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
                handle_error "Invalid version format: $param (expected: x.y or x.y.z)" "version validation"
                return 1
            fi
            ;;
    esac
    
    return 0
}

# Cleanup function for error scenarios
cleanup_on_error() {
    debug "Performing error cleanup..."
    
    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null || true
    
    # Clear sensitive cache data
    unset CONTAINER_STATUS_CACHE
    unset PROJECT_NAME_CACHE
    
    # Reset terminal state
    tput sgr0 2>/dev/null || true
}

# Command registry management functions
register_command() {
    local primary_cmd="$1"
    local handler_func="$2"
    local description="$3"
    local aliases="$4"
    local param_info="$5"
    
    # Register primary command
    COMMAND_REGISTRY["$primary_cmd"]="$handler_func"
    COMMAND_DESCRIPTIONS["$primary_cmd"]="$description"
    COMMAND_PARAMS["$primary_cmd"]="$param_info"
    
    # Register aliases
    if [[ -n "$aliases" ]]; then
        IFS=' ' read -ra alias_array <<< "$aliases"
        for alias in "${alias_array[@]}"; do
            COMMAND_ALIASES["$alias"]="$primary_cmd"
        done
    fi
    
    debug "Registered command: $primary_cmd with aliases: $aliases"
}

# Resolve command alias to primary command
resolve_command() {
    local cmd="$1"
    
    # Check if it's a primary command
    if [[ -n "${COMMAND_REGISTRY[$cmd]:-}" ]]; then
        echo "$cmd"
        return 0
    fi
    
    # Check if it's an alias
    if [[ -n "${COMMAND_ALIASES[$cmd]:-}" ]]; then
        echo "${COMMAND_ALIASES[$cmd]}"
        return 0
    fi
    
    # Command not found
    return 1
}

# Get command handler function
get_command_handler() {
    local cmd="$1"
    local primary_cmd
    
    if primary_cmd=$(resolve_command "$cmd"); then
        echo "${COMMAND_REGISTRY[$primary_cmd]}"
        return 0
    fi
    
    return 1
}

# List all registered commands
list_commands() {
    local category="${1:-all}"
    
    echo "Registered commands:"
    for cmd in "${!COMMAND_REGISTRY[@]}"; do
        local description="${COMMAND_DESCRIPTIONS[$cmd]}"
        local params="${COMMAND_PARAMS[$cmd]}"
        
        printf "  %-15s %s" "$cmd" "$description"
        [[ -n "$params" ]] && printf " %s" "$params"
        echo
        
        # Show aliases
        local aliases=()
        for alias in "${!COMMAND_ALIASES[@]}"; do
            if [[ "${COMMAND_ALIASES[$alias]}" == "$cmd" ]]; then
                aliases+=("$alias")
            fi
        done
        
        if [[ ${#aliases[@]} -gt 0 ]]; then
            printf "    aliases: %s\n" "${aliases[*]}"
        fi
    done
}

# Command handler functions
handle_project_start() {
    debug "Starting project..."
    start=1
}

handle_project_stop() {
    debug "Stopping project..."
    down=1
}

handle_project_restart() {
    debug "Restarting project..."
    restart=1
}

handle_project_status() {
    debug "Showing project status..."
    status=1
}

handle_project_launch() {
    debug "Opening in browser..."
    launch=1
    launchparam="${1-}"
}

handle_project_ssh() {
    debug "Connecting via SSH..."
    ssh=1
}

handle_db_export() {
    debug "Exporting database..."
    exportdb=1
    exportdbparam="${1-.project/db.sql.gz}"
}

handle_db_import() {
    debug "Importing database..."
    importdb=1
    importdbparam="${1-.project/db.sql.gz}"
}

handle_db_sequelace() {
    debug "Starting Sequel Ace..."
    sequelace=1
}

handle_db_migrate() {
    debug "Running database migrations..."
    console=1
    consoleparam="database:migrate ${1-}"
}

handle_db_migrate_all() {
    debug "Running all database migrations..."
    console=1
    consoleparam="database:migrate --all"
}

handle_dev_xdebug() {
    debug "Toggling xdebug..."
    xdebug=1
    xdebugparam="${1-on}"
}

handle_dev_test() {
    debug "Running tests..."
    test=1
    testparam="${1-}"
}

handle_dev_logs() {
    debug "Showing logs..."
    logs=1
}

handle_dev_mail() {
    debug "Starting mail server..."
    mail=1
}

handle_dev_debug_router() {
    debug "Running debug:router..."
    console=1
    consoleparam="debug:router"
}

handle_composer_command() {
    debug "Running composer command..."
    composer=1
    composerparam="${1-}"
}

handle_composer_update() {
    debug "Updating dependencies..."
    composer=1
    composerparam="update"
}

handle_composer_install() {
    debug "Installing dependencies..."
    composer=1
    composerparam="install"
}

handle_composer_require() {
    debug "Adding package..."
    require=1
    requireparam="${1-}"
}

handle_composer_remove() {
    debug "Removing package..."
    remove=1
    removeparam="${1-}"
}

handle_composer_dump_autoload() {
    debug "Updating autoloader..."
    composer=1
    composerparam="dump-autoload"
}

handle_composer_prefer_source() {
    debug "Setting prefer-source..."
    prefersource=1
    prefersourceparam="${1-}"
}

handle_console_command() {
    debug "Running console command..."
    console=1
    consoleparam="${1-}"
}

handle_cache_delete() {
    debug "Deleting cache..."
    deletecache=1
}

handle_cache_clear() {
    debug "Clearing cache..."
    console=1
    consoleparam="cache:clear"
}

handle_build_components() {
    debug "Building components..."
    build=1
    buildparam="${1-}"
}

handle_build_administration() {
    debug "Building administration..."
    build=1
    buildparam="administration"
}

handle_build_storefront() {
    debug "Building storefront..."
    build=1
    buildparam="storefront"
}

handle_build_js() {
    debug "Building JavaScript..."
    build=1
    buildparam="js"
}

handle_watch_components() {
    debug "Watching components..."
    watch=1
    watchparam="${1-}"
}

handle_watch_administration() {
    debug "Watching administration..."
    watch=1
    watchparam="administration"
}

handle_watch_storefront() {
    debug "Watching storefront..."
    watch=1
    watchparam="storefront"
}

handle_messenger_consume() {
    debug "Starting messenger consumer..."
    console=1
    consoleparam="messenger:consume"
}

handle_plugin_refresh() {
    debug "Refreshing plugins..."
    console=1
    consoleparam="plugin:refresh"
}

handle_plugin_list() {
    debug "Listing plugins..."
    console=1
    consoleparam="plugin:list"
}

handle_plugin_activate() {
    debug "Activating plugin..."
    console=1
    consoleparam="plugin:activate ${1-}"
}

handle_plugin_install() {
    debug "Installing plugin..."
    console=1
    consoleparam="plugin:install ${1-}"
}

handle_plugin_uninstall() {
    debug "Uninstalling plugin..."
    console=1
    consoleparam="plugin:uninstall ${1-}"
}

handle_plugin_update() {
    debug "Updating plugin..."
    console=1
    consoleparam="plugin:update ${1-}"
}

handle_plugin_deactivate() {
    debug "Deactivating plugin..."
    console=1
    consoleparam="plugin:deactivate ${1-}"
}

handle_project_new() {
    debug "Creating new project..."
    new=1
    newparam="${1-}"
    if [[ -z "$newparam" ]]; then
        read -r -p "Project type (symfony|shopware): " newparam
    fi
    
    # Normalize project type
    case "$newparam" in
    symfony | sy | sym)
        newparam="symfony"
        ;;
    shopware | sw | sh | sho | shop)
        newparam="shopware"
        ;;
    *)
        handle_error "Unknown project type: $newparam. Use symfony or shopware" "project creation"
        return 1
        ;;
    esac
}

handle_project_init() {
    debug "Initializing project..."
    init=1
}

handle_project_backup() {
    debug "Creating backup..."
    backup=1
}

handle_project_restore() {
    debug "Restoring from backup..."
    restore=1
    restoreparam="${1-}"
}

handle_script_upgrade() {
    debug "Upgrading script..."
    upgrade
}

handle_script_setup() {
    debug "Setting up configuration..."
    setup_config
    exit 0
}

handle_unknown_command() {
    local command="$1"
    shift
    debug "Executing command in container: $command $*"
    ddev exec "$command" "$@"
}

# Initialize command registry
init_command_registry() {
    debug "Initializing command registry..."
    
    # Project commands
    register_command "start" "handle_project_start" "Start project" "u up" ""
    register_command "stop" "handle_project_stop" "Stop project" "d down" ""
    register_command "restart" "handle_project_restart" "Restart project" "r" ""
    register_command "status" "handle_project_status" "Show project status" "st sta stat info" ""
    register_command "launch" "handle_project_launch" "Open in browser" "o" "[url]"
    register_command "ssh" "handle_project_ssh" "Connect via SSH" "s" ""
    
    # Database commands
    register_command "export" "handle_db_export" "Export database" "e" "[file]"
    register_command "import" "handle_db_import" "Import database" "i" "[file]"
    register_command "sequelace" "handle_db_sequelace" "Start Sequel Ace" "se seq" ""
    register_command "database:migrate" "handle_db_migrate" "Run database migrations" "dami da:mi" "[options]"
    register_command "database:migrate:all" "handle_db_migrate_all" "Run all database migrations" "damiall da:mi:all" ""
    
    # Development commands
    register_command "xdebug" "handle_dev_xdebug" "Enable/disable xdebug" "x" "[on|off]"
    register_command "test" "handle_dev_test" "Run tests" "t" "[options]"
    register_command "logs" "handle_dev_logs" "Show logs" "l" ""
    register_command "mail" "handle_dev_mail" "Start mail server" "m ma" ""
    register_command "debug:router" "handle_dev_debug_router" "Show routing information" "dr de:ro" ""
    
    # Composer commands
    register_command "composer" "handle_composer_command" "Run composer command" "com" "[command]"
    register_command "update" "handle_composer_update" "Update dependencies" "cup" ""
    register_command "install" "handle_composer_install" "Install dependencies" "cin" ""
    register_command "require" "handle_composer_require" "Add package" "cre" "[package]"
    register_command "remove" "handle_composer_remove" "Remove package" "crm" "[package]"
    register_command "dump-autoload" "handle_composer_dump_autoload" "Update autoloader" "ca cda" ""
    register_command "prefer-source" "handle_composer_prefer_source" "Reinstall package with source" "src source" "[package]"
    
    # Console commands
    register_command "console" "handle_console_command" "Run console command" "c" "[command]"
    register_command "cache:delete" "handle_cache_delete" "Delete cache files" "cd cade ca:de" ""
    register_command "cache:clear" "handle_cache_clear" "Clear cache" "cc cacl ca:cl" ""
    
    # Build commands
    register_command "build" "handle_build_components" "Build components" "b" "[component]"
    register_command "build:administration" "handle_build_administration" "Build administration" "ba" ""
    register_command "build:storefront" "handle_build_storefront" "Build storefront" "bs" ""
    register_command "build:js" "handle_build_js" "Build JavaScript" "bj all" ""
    
    # Watch commands
    register_command "watch" "handle_watch_components" "Watch components" "w" "[component]"
    register_command "watch:administration" "handle_watch_administration" "Watch administration" "wa wa:ad" ""
    register_command "watch:storefront" "handle_watch_storefront" "Watch storefront" "ws wa:st" ""
    
    # Messenger commands
    register_command "messenger:consume" "handle_messenger_consume" "Run messenger consumer" "mc meco me:co" ""
    
    # Plugin commands
    register_command "plugin:refresh" "handle_plugin_refresh" "Refresh plugins" "plre pl:re" ""
    register_command "plugin:list" "handle_plugin_list" "List plugins" "pl pli plli pl:li" ""
    register_command "plugin:activate" "handle_plugin_activate" "Activate plugin" "plac pl:ac" "[plugin]"
    register_command "plugin:install" "handle_plugin_install" "Install plugin" "plin pl:in" "[plugin]"
    register_command "plugin:uninstall" "handle_plugin_uninstall" "Uninstall plugin" "plun pl:un" "[plugin]"
    register_command "plugin:update" "handle_plugin_update" "Update plugin" "pu plup pl:up" "[plugin]"
    register_command "plugin:deactivate" "handle_plugin_deactivate" "Deactivate plugin" "plde pl:de" "[plugin]"
    
    # Project management commands
    register_command "new" "handle_project_new" "Create new project" "n" "[type]"
    register_command "init" "handle_project_init" "Initialize project" "" ""
    register_command "backup" "handle_project_backup" "Create backup" "bk" ""
    register_command "restore" "handle_project_restore" "Restore from backup" "rs" "[file]"
    
    # System commands
    register_command "upgrade" "handle_script_upgrade" "Upgrade script" "" ""
    register_command "setup" "handle_script_setup" "Run configuration wizard" "" ""
    
    debug "Command registry initialized with ${#COMMAND_REGISTRY[@]} commands"
}

# Display usage information
usage() {
    cat <<EOF
$(basename "${BASH_SOURCE[0]}") - Development Command Line Tools v${VERSION}

USAGE:
    $(basename "${BASH_SOURCE[0]}") [OPTION] COMMAND [ARGS]

OPTIONS:
    -h,  --help          Show this help
    -v,  --version       Show version
         --no-color      Disable colored outpu
         --no-deprecations  Suppress deprecation warnings
    -vv, --verbose       Verbose outpu

CONFIGURATION:
    setup                Run configuration wizard
    You can customize settings by running 'dev setup' or by editing:
    $CONFIG_FILE
    Configuration options include:
    - DOCKER_ENVIRONMENT: orbstack or docker
    - PREFERRED_EDITOR: code, phpstorm, etc.
    - DEFAULT_PHP_VERSION: 8.2, 8.1, etc.
    - DEFAULT_NODE_VERSION: 20, 18, etc.
    - LOG_LEVEL: INFO, DEBUG

PROJECT:
    u,   up              Start projec
    d,   down            Stop projec
    r,   restart         Restart projec
    st,  status          Show project status
    o,   open            Open in browser
    s,   ssh             Connect via SSH
    init                 Initialize projec

DATABASE:
    e,   export [file]   Export database (.project/db.sql.gz)
    i,   import [file]   Import database
    seq, sequelace       Start Sequel Ace
    da:mi                Run database migrations
    da:mi:all            Run all database migrations

DEVELOPMENT:
    x,   xdebug          Enable/disable xdebug (on|off)
    t,   test            Run tests [options]
    l,   logs            Show logs
    m,   mail            Start mail server
    dr,  debug:router    Show routing information

CONSOLE:
    c,   console         Run console command
    cc,  cache:clear     Clear cache
    cd,  cache:delete    Delete cache files

COMPOSER:
    com, composer        Run composer command
    cup, update          Update dependencies
    cin, install         Install dependencies
    cre, require         Add package [pkg]
    crm, remove          Remove package [pkg]
    cda                  Update autoloader
    src, prefer-source   Reinstall package with source

SHOPWARE:
    b | build [comp]          Build components (js|admin|store)
    ba | build:administration Build administration
    bs | build:storefront     Build storefron
    bj | build:js             Build JavaScrip
    w | watch [comp]          Watch components
    cc | cache:clear          Clear cache
    cd | cache:delete         Delete cache files
    mc | messenger:consume    Run messenger consumer
    pl | plugin:list          List plugins
    plre | plugin:refresh     Refresh plugins
    plac | plugin:activate    Activate plugin
    plde | plugin:deactivate  Deactivate plugin
    plin | plugin:install     Install plugin
    plun | plugin:uninstall   Uninstall plugin
    pu | plup | pl:up | plugin:update      Update plugin

Examples:
    dev        Start development environmen
    dev u      Start projec
    dev ci     Composer Install
    dev new    Create new projec
    dev ba     bin/build-administration
    dev x on   Enable xdebug
EOF
    exit 0
}

# Simple versioning and message output
version() {
    echo -e "dev-cli-tools ${VERSION}\nhttps://github.com/akaw/dev-cli-tools/"
    exit 0
}

# Cleanup function to handle script termination
cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    # Stop all running processes
    jobs -p | xargs -r kill
    # Remove temporary files if they exis
    if [ -n "${TEMP_DIR-}" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
    # Clear performance caches
    unset CONTAINER_STATUS_CACHE
    unset PROJECT_NAME_CACHE
}

# Performance optimization: Cache management functions
get_current_timestamp() {
    date +%s
}

is_cache_valid() {
    local cache_key="$1"
    local current_time
    current_time=$(get_current_timestamp)
    
    if [[ -n "${CONTAINER_STATUS_CACHE[$cache_key]:-}" ]]; then
        local cached_data="${CONTAINER_STATUS_CACHE[$cache_key]}"
        local cached_time="${cached_data##*:}"
        local age=$((current_time - cached_time))
        
        if [[ $age -lt $CACHE_TTL ]]; then
            debug "Cache hit for $cache_key (age: ${age}s)"
            return 0
        else
            debug "Cache expired for $cache_key (age: ${age}s)"
            unset "CONTAINER_STATUS_CACHE[$cache_key]"
        fi
    fi
    return 1
}

cache_container_status() {
    local project_name="$1"
    local status="$2"
    local timestamp
    timestamp=$(get_current_timestamp)
    
    CONTAINER_STATUS_CACHE["$project_name"]="${status}:${timestamp}"
    debug "Cached status for $project_name: $status"
}

get_cached_container_status() {
    local project_name="$1"
    if is_cache_valid "$project_name"; then
        local cached_data="${CONTAINER_STATUS_CACHE[$project_name]}"
        echo "${cached_data%%:*}"  # Return status part before ':'
        return 0
    fi
    return 1
}

# Performance monitoring function
show_cache_stats() {
    if [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
        local cache_count=${#CONTAINER_STATUS_CACHE[@]}
        local project_cache_count=${#PROJECT_NAME_CACHE[@]}
        debug "Cache statistics: Container status entries: $cache_count, Project name entries: $project_cache_count"
        
        if [[ $cache_count -gt 0 ]]; then
            for key in "${!CONTAINER_STATUS_CACHE[@]}"; do
                local cached_data="${CONTAINER_STATUS_CACHE[$key]}"
                local status="${cached_data%%:*}"
                local timestamp="${cached_data##*:}"
                local age=$(($(get_current_timestamp) - timestamp))
                debug "  $key: $status (age: ${age}s)"
            done
        fi
    fi
}

# Clear expired cache entries
cleanup_expired_cache() {
    local current_time
    current_time=$(get_current_timestamp)
    
    for key in "${!CONTAINER_STATUS_CACHE[@]}"; do
        local cached_data="${CONTAINER_STATUS_CACHE[$key]}"
        local cached_time="${cached_data##*:}"
        local age=$((current_time - cached_time))
        
        if [[ $age -ge $CACHE_TTL ]]; then
            debug "Removing expired cache entry: $key (age: ${age}s)"
            unset "CONTAINER_STATUS_CACHE[$key]"
        fi
    done
}

# Simplified color output
setup_colors() {
    NOFORMAT='\033[0m'
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
}

# Simple message output
msg() {
    echo "$1"
}

# Default function to start the development environmen
# This function is called when no arguments are provided
default() {
    # Ensure Docker environment is ready with retry logic
    if ! ensure_docker_environment; then
        error "Docker environment is not ready. Please start Docker and try again."
        return 1
    fi
    
    # Check if DDEV project exists and start it with timeout
    if timeout 10 ddev describe >/dev/null 2>&1; then
        ensure_ddev_project
        ddev describe
        ddev sequelace
        ddev launch
    else
        warn "No DDEV project found in current directory or DDEV is not responding."
        warn "Use 'ddev config' to initialize a new project or change to a project directory."
        warn "If this is the first run after system restart, Docker might still be starting up."
        info "Try running the command again in a few seconds."
    fi
    # Open editor if configured
    if [[ -n "$PREFERRED_EDITOR" ]]; then
        debug "Opening project in $PREFERRED_EDITOR"
        $PREFERRED_EDITOR .
    fi
}

# Function to upgrade the script
upgrade() {
    local script_path="${BASH_SOURCE[0]}"
    info "Checking for updates..."

    # Temporary files for downloads
    local temp_script="/tmp/dev_new_version"
    local temp_hash="/tmp/dev_new_version.sha256"

    # Check current version against latest version first
    local latest_version
    if ! latest_version=$(curl -s -m 5 "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev" | grep -m 1 "^VERSION=" | cut -d'"' -f2); then
        handle_error "Could not check for updates. Please check your internet connection." "update check"
        info "Possible solutions:"
        info "  - Check your internet connection"
        info "  - Verify firewall settings"
        info "  - Try again later"
        return 1
    fi
    
    validate_param "$latest_version" "latest_version" "version_format" || {
        handle_error "Invalid version format received from server: $latest_version" "update check"
        return 1
    }

    if [[ "$latest_version" == "$VERSION" ]]; then
        info "You already have the latest version ($VERSION)."
        return 0
    fi

    info "New version found: $latest_version (current: $VERSION)"
    info "Downloading update..."

    # Download new version and hash file with better error handling
    if ! curl -s -o "$temp_script" "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev"; then
        handle_error "Download of new version failed" "update download"
        info "Please check your internet connection and try again"
        return 1
    fi

    if ! curl -s -o "$temp_hash" "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev.sha256"; then
        handle_error "Download of hash file failed" "update download"
        rm -f "$temp_script"
        info "Please check your internet connection and try again"
        return 1
    fi
    
    # Verify downloaded files are not empty
    if [[ ! -s "$temp_script" ]]; then
        handle_error "Downloaded script file is empty" "update download"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi
    
    if [[ ! -s "$temp_hash" ]]; then
        handle_error "Downloaded hash file is empty" "update download"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    # Verify hash
    local expected_hash
    expected_hash=$(cat "$temp_hash")
    local actual_hash

    # Validate expected hash format
    if [[ ! "$expected_hash" =~ ^[a-f0-9]{64}$ ]]; then
        handle_error "Invalid hash format received: $expected_hash" "hash verification"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    if command -v shasum >/dev/null 2>&1; then
        # macOS typically uses shasum
        if ! actual_hash=$(shasum -a 256 "$temp_script" 2>/dev/null | awk '{print $1}'); then
            handle_error "Failed to calculate SHA256 hash using shasum" "hash verification"
            rm -f "$temp_script" "$temp_hash"
            return 1
        fi
    elif command -v sha256sum >/dev/null 2>&1; then
        # Linux typically uses sha256sum
        if ! actual_hash=$(sha256sum "$temp_script" 2>/dev/null | awk '{print $1}'); then
            handle_error "Failed to calculate SHA256 hash using sha256sum" "hash verification"
            rm -f "$temp_script" "$temp_hash"
            return 1
        fi
    else
        handle_error "No SHA256 utility found (shasum or sha256sum required)" "hash verification"
        info "Please install a SHA256 utility and try again"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    if [[ "$actual_hash" != "$expected_hash" ]]; then
        handle_error "Hash verification failed! The update might be compromised." "hash verification"
        error "Expected: $expected_hash"
        error "Actual: $actual_hash"
        info "This could indicate:"
        info "  - Network corruption during download"
        info "  - Compromised update server"
        info "  - Man-in-the-middle attack"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    # Create backup
    cp "$script_path" "${script_path}.backup"

    # Remove update marker to force version check on next run
    rm -f "/tmp/dev_update_check_$(date +%Y%m%d)" 2>/dev/null

    # Backup current script with error handling
    if ! cp "$script_path" "${script_path}.backup"; then
        handle_error "Failed to create backup of current script" "update installation"
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    # Install new version with atomic operation
    if mv "$temp_script" "$script_path"; then
        if ! chmod +x "$script_path"; then
            handle_error "Failed to set executable permissions on updated script" "update installation"
            # Restore backup
            mv "${script_path}.backup" "$script_path"
            rm -f "$temp_hash"
            return 1
        fi
        
        rm -f "$temp_hash"
        info "Update successful!"
        
        # Get the new version directly from the script
        local new_version
        if new_version=$(grep -m 1 "^VERSION=" "$script_path" | cut -d'"' -f2); then
            VERSION="$new_version"
            info "New version: ${VERSION}"
        else
            warn "Could not determine new version from updated script"
        fi
        
        info "Please restart your shell or run 'hash -r' to clear command cache."
    else
        handle_error "Failed to install updated script" "update installation"
        info "Restoring backup..."
        if ! mv "${script_path}.backup" "$script_path"; then
            handle_error "CRITICAL: Failed to restore backup! Script may be corrupted." "update installation"
            info "Please manually restore from: ${script_path}.backup"
        fi
        rm -f "$temp_script" "$temp_hash"
        return 1
    fi

    rm -f "${script_path}.backup"
    exit 0
}

# Enhanced file existence check with better error handling
check_file_exists() {
    local file_path="$1"
    local context="${2:-file check}"
    
    validate_param "$file_path" "file_path" "non_empty" || return 1
    
    if [[ ! -f "$file_path" ]]; then
        handle_error "File not found: $file_path" "$context"
        return 1
    fi
    
    debug "File exists: $file_path"
    return 0
}

# Enhanced Docker environment verification with retry logic
ensure_docker_environment() {
    # Skip docker checks in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping Docker environment check"
        return 0
    fi

    debug "Verifying Docker environment..."

    # Check if DDEV is installed
    if ! command -v ddev &>/dev/null; then
        handle_error "ddev is not installed. Please install ddev first." "docker environment check"
        info "Visit https://ddev.readthedocs.io/en/stable/#installation for installation instructions"
        return 1
    fi

    # Check DDEV version compatibility
    local ddev_version
    if ddev_version=$(timeout 5 ddev version --json-output 2>/dev/null | grep -o '"DDEV version":"[^"]*"' | cut -d'"' -f4); then
        debug "DDEV version: $ddev_version"
    else
        debug "Could not determine DDEV version (might be starting up)"
    fi

    # Check if Docker is running with retry logic for startup scenarios
    local retry_count=0
    local max_retries=3
    local docker_ready=false
    
    while [[ $retry_count -lt $max_retries ]]; do
        debug "Docker check attempt $((retry_count + 1))/$max_retries"
        
        # Check if Docker is running and responsive with timeout
        if timeout 8 docker info >/dev/null 2>&1; then
            debug "Docker daemon is responsive"
            docker_ready=true
            break
        else
            debug "Docker not responsive, waiting..."
            if [[ $retry_count -lt $((max_retries - 1)) ]]; then
                sleep 2
            fi
            ((retry_count++))
        fi
    done
    
    if [[ "$docker_ready" != "true" ]]; then
        handle_error "Docker is not running or not responsive after $max_retries attempts" "docker environment check"
        info "Please start your Docker environment (Docker Desktop, OrbStack, etc.) and try again"
        info "Common solutions:"
        info "  - Start Docker Desktop and wait for it to fully initialize"
        info "  - Check if Docker daemon is running"
        info "  - Verify Docker permissions"
        info "  - After system restart, Docker may take a minute to start"
        return 1
    fi

    # Verify Docker connectivity
    if ! docker ps >/dev/null 2>&1; then
        handle_error "Docker is running but not accessible" "docker environment check"
        info "This might be a permissions issue. Try running with appropriate permissions."
        return 1
    fi

    debug "Docker environment is ready."
    return 0
}

# Create project structure and initialize configuration
create_project_structure() {
    local project_type=$1
    local project_name=${2:-$(basename "$PWD")}

    debug "Creating project structure for: $project_type ($project_name)"

    # Create basic project structure
    mkdir -p .project/{backups,config,scripts}

    # Create common configuration
    cat >.project/config/common.env <<EOL
APP_ENV=dev
APP_DEBUG=1
COMPOSER_MEMORY_LIMIT=-1
EOL

    # Project specific configurations
    case "$project_type" in
    "symfony")
        debug "Setting up Symfony project configuration"
        cat >.project/config/ddev.yaml <<EOL
name: $project_name
type: php
docroot: public
php_version: "${DEFAULT_PHP_VERSION}"
nodejs_version: "${DEFAULT_NODE_VERSION}"
mysql_version: "${DEFAULT_MYSQL_VERSION}"
webserver_type: nginx-fpm
web_environment:
- DATABASE_URL=mysql://db:db@db:3306/db
- MAILER_DSN=smtp://localhost:1025
- APP_ENV=dev
- APP_DEBUG=1

hooks:
  post-start:
    - exec: composer install
    - exec: bin/console cache:clear
EOL
        ;;
    "shopware")
        debug "Setting up Shopware project configuration"
        cat >.project/config/ddev.yaml <<EOL
name: $project_name
type: shopware6
docroot: shopware/public
php_version: "${DEFAULT_PHP_VERSION}"
nodejs_version: "${DEFAULT_NODE_VERSION}"
mysql_version: "${DEFAULT_MYSQL_VERSION}"
webserver_type: apache-fpm
web_environment:
- DATABASE_URL=mysql://db:db@db:3306/db
- MAILER_DSN=smtp://localhost:1025?encryption=&auth_mode=
- APP_URL=\${DDEV_PRIMARY_URL}
- APP_ENV=dev
- APP_DEBUG=1
- LOCK_DSN=flock

hooks:
  post-start:
    - exec: composer install
    - exec: bin/console cache:clear
    - exec: bin/build-js.sh
EOL

        # Create Shopware specific scripts
        cat >.project/scripts/build-all.sh <<EOL
#!/bin/bash
bin/build-js.sh
bin/build-storefront.sh
bin/build-administration.sh
EOL
        chmod +x .project/scripts/build-all.sh
        ;;
            *)
            handle_error "Unsupported project type: $project_type" "project structure creation"
            info "Supported project types: symfony, shopware"
            return 1
            ;;
    esac

    # Create gitignore if it doesn't exis
    if [[ ! -f ".gitignore" ]]; then
        cat >.gitignore <<EOL
/.project/backups/
/.env.local
/vendor/
/var/
/node_modules/
*.log
.DS_Store
EOL
    fi

    debug "Project structure created successfully"
    return 0
}

# Setup build tools for projec
setup_build_tools() {
    local project_type=$1

    debug "Setting up build tools for: $project_type"

    case "$project_type" in
    "symfony")
        debug "Installing Symfony build dependencies"
        ddev composer require --dev symfony/webpack-encore
        ddev npm install
        ;;

    "shopware")
        debug "Installing Shopware build dependencies"
        ddev npm clean-install
        ddev npm run build
        ;;
    esac

    # Create common build scripts
    mkdir -p .project/scripts

    # Create build scrip
    cat >.project/scripts/build.sh <<EOL
#!/bin/bash
set -e

echo "Building project assets..."
if [ -f "bin/build-js.sh" ]; then
    bin/build-js.sh
fi

if [ -f "bin/build-storefront.sh" ]; then
    bin/build-storefront.sh
fi

if [ -f "bin/build-administration.sh" ]; then
    bin/build-administration.sh
fi

if [ -f "node_modules/.bin/encore" ]; then
    node_modules/.bin/encore production
fi

echo "Build completed successfully"
EOL
    chmod +x .project/scripts/build.sh

    debug "Build tools setup completed"
    return 0
}

# Load configuration from file
load_config() {
    # Skip if we're in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping config loading"
        return 0
    fi

    if [[ -f "$CONFIG_FILE" && -r "$CONFIG_FILE" ]]; then
        debug "Loading configuration from $CONFIG_FILE"
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        return 0
    else
        debug "No configuration file found at $CONFIG_FILE or file not readable"
        return 1
    fi
}

# Save configuration to file
save_config() {
    debug "Saving configuration to $CONFIG_FILE"

    # Create directory if it doesn't exis
    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Clear existing file
    true > "$CONFIG_FILE"

    # Write configuration values
    echo "# DEV CLI Tools Configuration" > "$CONFIG_FILE"
    echo "# Generated on $(date)" >> "$CONFIG_FILE"
    echo "" >> "$CONFIG_FILE"

    [[ -n "$DOCKER_ENVIRONMENT" ]] && echo "export DOCKER_ENVIRONMENT=\"$DOCKER_ENVIRONMENT\"" >> "$CONFIG_FILE"
    [[ -n "$PREFERRED_EDITOR" ]] && echo "export PREFERRED_EDITOR=\"$PREFERRED_EDITOR\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_PHP_VERSION" ]] && echo "export DEFAULT_PHP_VERSION=\"$DEFAULT_PHP_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_NODE_VERSION" ]] && echo "export DEFAULT_NODE_VERSION=\"$DEFAULT_NODE_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$DEFAULT_MYSQL_VERSION" ]] && echo "export DEFAULT_MYSQL_VERSION=\"$DEFAULT_MYSQL_VERSION\"" >> "$CONFIG_FILE"
    [[ -n "$LOG_LEVEL" ]] && echo "export LOG_LEVEL=\"$LOG_LEVEL\"" >> "$CONFIG_FILE"

    info "Configuration saved to $CONFIG_FILE"
}

# Setup configuration
setup_config() {
    info "Welcome to DEV CLI Tools Setup"
    info "This will configure your preferences for DEV CLI Tools"
    echo ""

    # Docker environmen
    echo "Select your preferred Docker environment:"
    echo "1) OrbStack (recommended for macOS)"
    echo "2) Docker Desktop"
    echo "3) Native Docker (Linux)"
    echo ""
    read -r -p "Enter your choice [1-3, default: 1]: " docker_choice

    case "${docker_choice:-1}" in
        1) DOCKER_ENVIRONMENT="orbstack" ;;
        2) DOCKER_ENVIRONMENT="docker" ;;
        3) DOCKER_ENVIRONMENT="docker" ;;
        *) DOCKER_ENVIRONMENT="orbstack" ;;
    esac

    echo ""
    echo "Docker environment set to: $DOCKER_ENVIRONMENT"
    echo ""

    # Preferred editor
    echo "Select your preferred code editor:"
    echo "1) No default editor"
    echo "2) Visual Studio Code (code)"
    echo "3) PhpStorm (phpstorm)"
    echo "4) Sublime Text (subl)"
    echo "5) Custom (specify command)"
    echo ""
    read -r -p "Enter your choice [1-5, default: 1]: " editor_choice

    case "${editor_choice:-1}" in
        1) PREFERRED_EDITOR="" ;;
        2) PREFERRED_EDITOR="code" ;;
        3) PREFERRED_EDITOR="phpstorm" ;;
        4) PREFERRED_EDITOR="subl" ;;
        5)
            read -r -p "Enter the command to open your editor: " custom_editor
            PREFERRED_EDITOR="$custom_editor"
            ;;
        *) PREFERRED_EDITOR="" ;;
    esac

    if [[ -n "$PREFERRED_EDITOR" ]]; then
        echo "Preferred editor set to: $PREFERRED_EDITOR"
    else
        echo "No default editor set"
    fi
    echo ""

    # Default PHP version
    read -r -p "Enter default PHP version [default: 8.2]: " php_version
    DEFAULT_PHP_VERSION="${php_version:-8.2}"
    echo "Default PHP version set to: $DEFAULT_PHP_VERSION"
    echo ""

    # Default Node.js version
    read -r -p "Enter default Node.js version [default: 20]: " node_version
    DEFAULT_NODE_VERSION="${node_version:-20}"
    echo "Default Node.js version set to: $DEFAULT_NODE_VERSION"
    echo ""

    # Default MySQL version
    read -r -p "Enter default MySQL version [default: 8.0]: " mysql_version
    DEFAULT_MYSQL_VERSION="${mysql_version:-8.0}"
    echo "Default MySQL version set to: $DEFAULT_MYSQL_VERSION"
    echo ""

    # Log level
    echo "Select log level:"
    echo "1) INFO (standard level, recommended)"
    echo "2) DEBUG (verbose output for troubleshooting)"
    echo ""
    read -r -p "Enter your choice [1-2, default: 1]: " log_level_choice

    case "${log_level_choice:-1}" in
        1) LOG_LEVEL="INFO" ;;
        2) LOG_LEVEL="DEBUG" ;;
        *) LOG_LEVEL="INFO" ;;
    esac

    echo "Log level set to: $LOG_LEVEL"
    echo ""

    # Save configuration
    save_config

    info "Setup complete! Your preferences have been saved."
    info "You can change these settings any time by running 'dev setup' again."
    echo ""
}

# Check if this might be the first run after system restart
is_likely_first_run_after_restart() {
    # Check system uptime (if available) - extended time window
    if command -v uptime >/dev/null 2>&1; then
        local uptime_minutes
        # Try different uptime formats (macOS, Linux)
        if uptime_minutes=$(uptime | grep -o 'up [0-9]* min' | grep -o '[0-9]*' 2>/dev/null); then
            # If system has been up for less than 15 minutes, likely first run
            if [[ -n "$uptime_minutes" && "$uptime_minutes" -lt 15 ]]; then
                debug "System uptime: ${uptime_minutes} minutes - first run after restart"
                return 0
            fi
        elif uptime | grep -q "up.*day" 2>/dev/null; then
            # System has been up for days - definitely not first run
            debug "System uptime: multiple days - not first run after restart"
            return 1
        elif uptime | grep -q "up.*hr" 2>/dev/null; then
            # System has been up for hours - probably not first run
            debug "System uptime: multiple hours - not first run after restart"
            return 1
        fi
    fi
    
    # Check if this is the first dev command today
    local first_run_marker
    first_run_marker="/tmp/dev_first_run_$(date +%Y%m%d)"
    if [[ ! -f "$first_run_marker" ]]; then
        debug "No first run marker found for today - treating as first run"
        touch "$first_run_marker" 2>/dev/null || true
        return 0
    fi
    
    # Check if Docker was recently started (container creation times)
    if command -v docker >/dev/null 2>&1 && timeout 3 docker info >/dev/null 2>&1; then
        local recent_containers
        if recent_containers=$(timeout 3 docker ps -a --format "table {{.CreatedAt}}" --filter "since=15m" 2>/dev/null | wc -l 2>/dev/null); then
            if [[ "$recent_containers" -lt 3 ]]; then
                debug "Few recent Docker containers ($recent_containers) - might be first run after restart"
                return 0
            fi
        fi
    fi
    
    debug "Not first run after restart - normal operation"
    return 1
}

# Function to check for updates (only on first run after restart)
check_for_updates() {
    # Skip update check in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping update check"
        return 0
    fi

    # Skip if we've already checked recently (within 24 hours)
    local update_marker
    update_marker="/tmp/dev_update_check_$(date +%Y%m%d)"
    if [[ -f "$update_marker" ]]; then
        debug "Update already checked today, skipping check"
        return 0
    fi

    # Only check for updates if this looks like first run after restart
    if ! is_likely_first_run_after_restart; then
        debug "Skipping update check - not first run after system restart"
        return 0
    fi

    debug "First run after restart detected - checking for updates..."

    # Try to get the latest version from GitHub with reasonable timeout
    local latest_version
    if ! latest_version=$(timeout 5 curl -s -m 5 "https://raw.githubusercontent.com/akaw/dev-cli-tools/main/src/dev" 2>/dev/null | grep -m 1 "^VERSION=" | cut -d'"' -f2 2>/dev/null); then
        debug "Could not check for updates (network timeout or unavailable)"
        # Don't create marker on failure, allow retry next time
        return 0
    fi

    # Create marker only after successful check
    touch "$update_marker" 2>/dev/null || true

    debug "Current version: $VERSION, Latest version: $latest_version"

    # Compare versions (simple string comparison, assumes semantic versioning)
    if [[ "$latest_version" != "$VERSION" && -n "$latest_version" ]]; then
        info "ðŸ”„ A new version ($latest_version) of dev-cli-tools is available!"
        info "You're currently using version $VERSION."
        info "Run 'dev upgrade' to update to the latest version."
        echo ""
    else
        debug "You have the latest version ($VERSION)"
    fi

    return 0
}

# Enhanced command parsing with registry
parse_params() {
    # Initialize all command flags
    init_command_flags

    # Get the command (first argument)
    local command="${1-}"
    [[ -z "$command" ]] && return 0
    shift || true

    # Try to find command handler
    local handler
    if handler=$(get_command_handler "$command"); then
        debug "Found handler for command: $command -> $handler"
        
        # Execute the handler with remaining arguments
        if ! "$handler" "$@"; then
            handle_error "Command handler failed: $command" "command execution"
            return 1
        fi
        
        return 0
    fi
    
    # Fallback to unknown command handler
    debug "No specific handler found for command: $command"
    handle_unknown_command "$command" "$@"
    return 0
}

# Removed legacy parse_params function - now using command registry system

# Initialize command flags
init_command_flags() {
    # Project commands
    new=0
    newparam=""
    start=0
    down=0
    restart=0
    status=0
    init=0
    ssh=0

    # Database commands
    exportdb=0
    exportdbparam=""
    importdb=0
    importdbparam=""
    sequelace=0

    # Development commands
    xdebug=0
    xdebugparam=""
    test=0
    testparam=""
    logs=0
    mail=0
    deletecache=0

    # Console commands
    console=0
    consoleparam=""
    no_deprecations=0
    verbose=0

    # Build commands
    build=0
    buildparam=""
    watch=0
    watchparam=""

    # Composer commands
    composer=0
    composerparam=""
    require=0
    requireparam=""
    remove=0
    removeparam=""

    # Package commands
    packages=0
    packagesparam=""
    prefersource=0
    prefersourceparam=""

    # Launch commands
    launch=0
    launchparam=""

    # Backup commands
    backup=0
    restore=0
    restoreparam=""

    # System flags
    version=0
    lint=0
    NO_COLOR=0
}

# Main execution
main() {
    # Setup colors firs
    setup_colors

    # Handle global options
    while [[ "${1-}" =~ ^- ]]; do
        case "${1-}" in
        --no-color)
            NO_COLOR=1
            shift
            ;;
        --no-deprecations)
            no_deprecations=1
            shift
            ;;
        -vv | --verbose)
            verbose=1
            shift
            ;;
        -v | --version)
            version
            exit 0
            ;;
        -h | --help)
            usage
            exit 0
            ;;
        *)
            break
            ;;
        esac
    done

    # Load configuration if available
    load_config || debug "No existing configuration found, using defaults"
    
    # Initialize command registry
    init_command_registry

    # Skip configuration setup in test mode or for special commands
    if [[ ! "${DEV_TEST_MODE:-}" == "true" ]] && [[ ! -f "$CONFIG_FILE" ]]; then
        info "This appears to be your first time running DEV CLI Tools."
        info "Would you like to set up your preferences now?"
        read -r -p "Run setup wizard? [Y/n]: " setup_response
        case "${setup_response:-y}" in
            [Yy]*)
                setup_config
                ;;
            *)
                info "You can run setup any time with 'dev setup'"
                ;;
        esac
    fi

    # Enable debug logging if se
    if [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
        debug "Debug mode enabled"
        debug "Operating system: $OS"
        debug "Docker environment: ${DOCKER_ENVIRONMENT:-not set}"
    fi

    # Check for updates (only on first run after restart when network is likely stable)
    if [[ "${SKIP_UPDATE_CHECK:-}" != "true" ]]; then
        check_for_updates
    else
        debug "Update check skipped (SKIP_UPDATE_CHECK=true)"
    fi

    # No arguments provided
    if [ $# -eq 0 ]; then
        default
        exit 0
    fi

    # Parse and execute commands
    parse_params "$@"
    execute_commands
    
    # Performance monitoring and cleanup
    show_cache_stats
    cleanup_expired_cache

    exit 0
}

# Execute commands based on flags
execute_commands() {
    # Execute console commands
    if [[ $console == 1 ]]; then
        execute_with_container "console command" _execute_console_command
    fi

    # Run composer commands
    if [[ $composer == 1 ]]; then
        execute_with_container "composer command" _execute_composer_command
    fi

    # Handle package requirements
    if [[ $require == 1 ]]; then
        execute_with_container "package require" _execute_require_command
    fi

    # Handle package removal
    if [[ $remove == 1 ]]; then
        execute_with_container "package remove" _execute_remove_command
    fi

    # Build shopware components
    if [[ $build == 1 ]]; then
        execute_with_container "build components" _execute_build_command
    fi

    # Watch components
    if [[ $watch == 1 ]]; then
        execute_with_container "watch components" _execute_watch_command
    fi

    # Database operations
    if [[ $exportdb == 1 ]]; then
        execute_with_container "database export" _execute_export_command
    fi

    if [[ $importdb == 1 ]]; then
        execute_with_container "database import" _execute_import_command
    fi

    # Project operations
    if [[ $start == 1 ]]; then
        execute_with_docker "start project" _execute_start_command
    fi

    if [[ $down == 1 ]]; then
        execute_with_docker "stop project" _execute_stop_command
    fi

    if [[ $restart == 1 ]]; then
        execute_with_docker "restart project" _execute_restart_command
    fi

    if [[ $status == 1 ]]; then
        execute_with_docker "project status" _execute_status_command
    fi

    # Direct command execution
    if [[ $ssh == 1 ]]; then
        execute_with_container "SSH connection" _execute_ssh_command
    fi

    if [[ $sequelace == 1 ]]; then
        execute_with_container "Sequel Ace" _execute_sequelace_command
    fi

    if [[ $launch == 1 ]]; then
        execute_with_container "launch browser" _execute_launch_command
    fi

    # Cache operations
    if [[ $deletecache == 1 ]]; then
        execute_with_container "delete cache" _execute_delete_cache_command
    fi

    # Testing
    if [[ $test == 1 ]]; then
        execute_with_container "run tests" _execute_test_command
    fi

    # Initialize projec
    if [[ $init == 1 ]]; then
        ensure_docker_environment
        debug "Initializing project..."
        read -r -p "Initialize DEV Environment? This will overwrite db and .env.local (y/n)?" choice
        case "$choice" in
        y | Y)
            info "Starting initialization..."
            check_file_exists ".project/init.sql.gz"
            check_file_exists ".project/env.ddev"
            ddev exec cp .env.ddev .env.local
            ddev start
            ddev import-db -f .project/init.sql.gz
            ddev describe
            ;;
        *)
            info "Initialization cancelled"
            ;;
        esac
    fi

    # Backup and restore
    if [[ $backup == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Creating backup..."
        mkdir -p "$BACKUP_DIR"
        local backup_file
        backup_file="${BACKUP_DIR}/backup-$(date '+%Y-%m-%d-%H-%M-%S').tar.gz"
        ddev exec tar -czf "$backup_file" .
        info "Backup created: $backup_file"
    fi

    if [[ $restore == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Restoring from backup: ${restoreparam-backup.tar.gz}"
        check_file_exists "${restoreparam-backup.tar.gz}"
        ddev exec tar -xzf "${restoreparam-backup.tar.gz}"
        info "Project restored from: ${restoreparam-backup.tar.gz}"
    fi

    # Mail server
    if [[ $mail == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Starting mail server..."
        ddev mailhog
    fi

    # Package handling
    if [[ $packages == 1 ]]; then
        ensure_docker_environment

        # Use our optimized container check function
        if ! check_and_ensure_running_container; then
            return 1
        fi

        debug "Processing packages..."
        process_packages
    fi

    # New project creation
    if [[ $new == 1 ]]; then
        ensure_docker_environment
        debug "Creating new project of type: $newparam"
        # Rest of new project creation code
    fi

    # Remove unnecessary variables
    unset new newparam start down restart status init ssh \
        exportdb exportdbparam importdb importdbparam sequelace \
        xdebug xdebugparam test testparam logs mail deletecache \
        console consoleparam no_deprecations verbose \
        build buildparam watch watchparam \
        composer composerparam require requireparam remove removeparam \
        packages packagesparam prefersource prefersourceparam \
        launch launchparam \
        backup restore restoreparam \
        version lint NO_COLOR \
        RED GREEN YELLOW NOFORMAT

    return 0
}

# Function to process packages and create symlinks
process_packages() {
    debug "Processing packages..."
    local base_dir="./"
    local vendor_dir="$base_dir/vendor"
    local plugins_dir="$base_dir/custom/plugins"

    # Create plugins directory if it doesn't exis
    mkdir -p "$plugins_dir"

    # Process store packages
    debug "Processing store packages..."
    if ! find "$vendor_dir/store.shopware.com" -name "composer.json" -type f -maxdepth 2 2>/dev/null | while read -r store_composer_file; do
        local path
        local link_name
        local link_path

        path=$(dirname "$store_composer_file" | sed "s|$vendor_dir/||")
        link_name=$(create_package_name "$path")
        link_path="$plugins_dir/$link_name"

        if [[ $packagesparam == "true" ]]; then
            debug "Creating symlink for $link_name"
            [ -L "$link_path" ] && unlink "$link_path"
            [ -d "$link_path" ] && rmdir "$link_path"
            ln -s "../../vendor/$path" "$link_path"
            info "Created symlink for $link_name"
        else
            echo "$link_name"
        fi
    done; then
        warn "No store packages found or error processing packages"
    fi
}

# Function to create a standardized package name
create_package_name() {
    if [[ $# -ne 1 ]]; then
        die "Usage: create_package_name <path>"
    fi

    local path="$1"
    local vendor
    local name

    vendor=$(echo "$path" | cut -d'/' -f1)
    name=$(echo "$path" | cut -d'/' -f2)

    # Capitalize first letter of vendor
    vendor="${vendor^}"

    # Convert kebab-case to PascalCase
    name=$(echo "$name" | sed -e 's/-/ /g' -e 's/\b\(.\)/\u\1/g' -e 's/ //g')

    echo "$vendor$name"
}

# Enhanced DDEV project directory validation
validate_ddev_directory() {
    local current_dir
    current_dir=$(pwd)
    
    # Check for .ddev directory
    if [[ ! -d ".ddev" ]]; then
        handle_error "No .ddev directory found in current directory: $current_dir" "ddev validation"
        info "This command requires a DDEV project."
        info "Solutions:"
        info "  - Change to a directory with a DDEV project"
        info "  - Initialize a new DDEV project with 'ddev config'"
        info "  - Create a new project with 'dev new'"
        return 1
    fi
    
    # Check for config.yaml
    if [[ ! -f ".ddev/config.yaml" ]]; then
        handle_error "DDEV configuration file not found: .ddev/config.yaml" "ddev validation"
        info "The .ddev directory exists but is missing the configuration file."
        info "Try running 'ddev config' to regenerate the configuration."
        return 1
    fi
    
    # Validate config.yaml is readable and has basic structure
    if ! grep -q "^name:" ".ddev/config.yaml" 2>/dev/null; then
        handle_error "Invalid or corrupted DDEV configuration file" "ddev validation"
        info "The .ddev/config.yaml file appears to be corrupted."
        info "Try running 'ddev config' to regenerate the configuration."
        return 1
    fi
    
    debug "Valid DDEV project found in: $current_dir"
    return 0
}

# Extract project name from DDEV configuration with caching
get_ddev_project_name() {
    local cache_key
    cache_key="project_name_$(pwd)"
    
    # Check cache first
    if [[ -n "${PROJECT_NAME_CACHE[$cache_key]:-}" ]]; then
        debug "Using cached project name"
        echo "${PROJECT_NAME_CACHE[$cache_key]}"
        return 0
    fi
    
    # Extract from config file
    local project_name
    if [[ -f ".ddev/config.yaml" ]]; then
        project_name=$(grep "name:" .ddev/config.yaml | head -n1 | awk '{print $2}')
        if [[ -n "$project_name" ]]; then
            PROJECT_NAME_CACHE["$cache_key"]="$project_name"
            debug "Cached project name: $project_name"
            echo "$project_name"
            return 0
        fi
    fi
    
    handle_error "Could not determine project name from .ddev/config.yaml" "project name extraction"
    info "Please ensure the DDEV configuration file contains a valid 'name:' entry"
    return 1
}

# Check if Docker container is running for given project (optimized)
is_docker_container_running() {
    local project_name="$1"
    
    # Check cache first
    local cached_status
    if cached_status=$(get_cached_container_status "$project_name"); then
        debug "Using cached container status: $cached_status"
        [[ "$cached_status" == "running" ]]
        return $?
    fi

    debug "Checking for running Docker container: ddev-${project_name}-web"

    # Use more efficient docker command with specific container name
    if docker container inspect "ddev-${project_name}-web" --format '{{.State.Status}}' 2>/dev/null | grep -q "running"; then
        debug "Docker container is running"
        cache_container_status "$project_name" "running"
        return 0
    else
        debug "Docker container is not running"
        cache_container_status "$project_name" "stopped"
        return 1
    fi
}

# Parse DDEV JSON status using jq or fallback to grep
parse_ddev_json_status() {
    local json_outputt="$1"

    if command -v jq >/dev/null 2>&1; then
        local status
        status=$(echo "$json_output" | jq -r '.[0].status' 2>/dev/null)
        debug "JSON status via jq: '$status'"
        [[ "$status" =~ ^[Rr]unning$ ]]
    else
        debug "Using grep fallback for JSON parsing"
        echo "$json_output" | grep -q '"status":"[Rr]unning"'
    fi
}

# Check if DDEV reports project as running via JSON API (optimized)
is_ddev_project_running() {
    local project_name="$1"
    
    # Check cache first
    local cached_status
    if cached_status=$(get_cached_container_status "$project_name"); then
        debug "Using cached DDEV status: $cached_status"
        [[ "$cached_status" == "running" ]]
        return $?
    fi

    debug "Checking DDEV status via JSON output"

    # Use timeout to prevent hanging
    local json_output
    if ! json_output=$(timeout 5 ddev describe --json-output 2>/dev/null); then
        debug "Failed to get JSON output from DDEV (timeout or error)"
        cache_container_status "$project_name" "error"
        return 1
    fi

    if parse_ddev_json_status "$json_output"; then
        debug "DDEV reports project as running"
        cache_container_status "$project_name" "running"
        return 0
    else
        debug "DDEV reports project as not running"
        cache_container_status "$project_name" "stopped"
        return 1
    fi
}

# Start DDEV project and handle errors (with cache invalidation)
start_ddev_project() {
    debug "Starting DDEV project..."

    # Get project name for cache invalidation
    local project_name
    if project_name=$(get_ddev_project_name 2>/dev/null); then
        # Invalidate cache before starting
        unset "CONTAINER_STATUS_CACHE[$project_name]"
        debug "Invalidated cache for project: $project_name"
    fi

    if ! ddev start; then
        handle_error "Failed to start DDEV project" "ddev start"
        info "Common solutions:"
        info "  - Check if Docker is running"
        info "  - Verify DDEV configuration with 'ddev config'"
        info "  - Check for port conflicts with 'ddev describe'"
        info "  - Review logs with 'ddev logs'"
        # Cache the failed state
        [[ -n "$project_name" ]] && cache_container_status "$project_name" "error"
        return 1
    fi

    # Cache successful start
    [[ -n "$project_name" ]] && cache_container_status "$project_name" "running"
    debug "DDEV project started successfully"
    return 0
}

# Check if project is running, start if needed (performance optimized)
check_and_ensure_running_container() {
    # Skip container checks in test mode
    if [[ "${DEV_TEST_MODE:-}" == "true" ]]; then
        debug "Test mode detected, skipping container status check"
        return 0
    fi

    # Validate we're in a DDEV project directory (cached)
    validate_ddev_directory || return 1

    # Get project name (cached)
    local project_name
    if ! project_name=$(get_ddev_project_name); then
        handle_error "Could not determine project name" "container check"
        info "Please ensure you're in a valid DDEV project directory"
        return 1
    fi
    debug "Found DDEV project: $project_name"

    # Fast path: Check cache first
    local cached_status
    if cached_status=$(get_cached_container_status "$project_name"); then
        if [[ "$cached_status" == "running" ]]; then
            debug "Project is running (cached) - no action needed"
            return 0
        elif [[ "$cached_status" == "error" ]]; then
            debug "Previous error cached, attempting fresh check"
            unset "CONTAINER_STATUS_CACHE[$project_name]"
        fi
    fi

    # Check if already running (optimized Docker check)
    if is_docker_container_running "$project_name"; then
        debug "Project is already running - no action needed"
        return 0
    fi

    # Fallback: check via DDEV JSON API (with timeout)
    if is_ddev_project_running "$project_name"; then
        debug "Project is running according to DDEV"
        return 0
    fi

    # Project is not running - start it
    debug "Project is not running - starting now"
    start_ddev_project
}

# Wrapper function for operations that require a running container
execute_with_container() {
    local operation_name="$1"
    shift
    
    debug "Executing $operation_name (requires running container)..."
    ensure_docker_environment
    
    if ! check_and_ensure_running_container; then
        handle_error "Failed to ensure container is running for: $operation_name" "container execution"
        info "Please check your DDEV project status and Docker environment"
        return 1
    fi
    
    # Execute the passed function/command
    "$@"
}

# Wrapper for operations that only need Docker environment (no container)
execute_with_docker() {
    local operation_name="$1"
    shift
    
    debug "Executing $operation_name (requires Docker environment)..."
    ensure_docker_environment
    
    # Execute the passed function/command
    "$@"
}

# Ensure DDEV project is running
ensure_ddev_project() {
    debug "Ensuring DDEV project is running..."
    check_and_ensure_running_container
}

# Alias for ensure_ddev_project (for backward compatibility)
check_ddev_project() {
    ensure_ddev_project
}

# Helper functions for common operations
run_console_command() {
    local cmd="$1"
    local flags="${2:-}"
    local env_vars="${3:-}"
    
    if [[ -n "$env_vars" ]]; then
        ddev exec "$env_vars" bin/console "$flags" "$cmd"
    else
        ddev exec bin/console "$flags" "$cmd"
    fi
}

run_composer_command() {
    local cmd="$1"
    ddev composer "$cmd"
}

run_build_command() {
    local component="$1"
    case "$component" in
        "storefront" | "store" | "s")
            ddev exec bin/build-storefront.sh
            ;;
        "administration" | "admin" | "a")
            ddev exec bin/build-administration.sh
            ;;
        "js" | "javascript" | "j")
            ddev exec bin/build-js.sh
            ;;
        *)
            warn "Unknown build component: $component"
            return 1
            ;;
    esac
}

run_watch_command() {
    local component="$1"
    case "$component" in
        "storefront" | "store" | "s")
            ddev exec bin/watch-storefront.sh
            ;;
        "administration" | "admin" | "a")
            ddev exec bin/watch-administration.sh
            ;;
        *)
            warn "Unknown watch component: $component"
            return 1
            ;;
    esac
}

# Internal function for console command execution
_execute_console_command() {
    # Special handling for cache:clear command to avoid unnecessary restarts
    if [[ $consoleparam == "cache:clear" ]]; then
        debug "Running cache:clear command directly..."

        local console_flags=""
        [[ $verbose == 1 ]] && console_flags+=" -v"

        # Add deprecation handling for Shopware console commands via environment variable
        if [[ -f "bin/console" && -d "vendor/shopware" ]]; then
            debug "Automatically suppressing deprecation warnings for Shopware via SYMFONY_DEPRECATIONS_HELPER"
            run_console_command "cache:clear" "$console_flags" "SYMFONY_DEPRECATIONS_HELPER=weak"
        else
            run_console_command "cache:clear" "$console_flags"
        fi
        return 0
    fi

    debug "Executing console command: $consoleparam"
    local console_flags=""
    local env_vars=""

    # Add deprecation handling for Shopware console commands via environment variable
    if [[ -f "bin/console" && -d "vendor/shopware" ]]; then
        env_vars="SYMFONY_DEPRECATIONS_HELPER=weak"
        debug "Automatically suppressing deprecation warnings for Shopware via SYMFONY_DEPRECATIONS_HELPER"
    fi

    # Still respect explicit flag if set, but use it only for logging purposes
    [[ $no_deprecations == 1 ]] && debug "Deprecation warnings suppressed via user flag"
    [[ $verbose == 1 ]] && console_flags+=" -v"

    run_console_command "$consoleparam" "$console_flags" "$env_vars"
}

# Internal function for composer command execution
_execute_composer_command() {
    debug "Running composer command: $composerparam"
    run_composer_command "$composerparam"
}

# Internal function for package require command
_execute_require_command() {
    debug "Adding package: $requireparam"
    if [[ $prefersource == 1 ]]; then
        run_composer_command "require $requireparam --prefer-source"
    else
        run_composer_command "require $requireparam"
    fi
}

# Internal function for package remove command
_execute_remove_command() {
    debug "Removing package: $removeparam"
    run_composer_command "remove $removeparam"
}

# Internal function for build command
_execute_build_command() {
    debug "Building components: $buildparam"
    run_build_command "$buildparam"
}

# Internal function for watch command
_execute_watch_command() {
    debug "Watching components: $watchparam"
    run_watch_command "$watchparam"
}

# Internal function for database export
_execute_export_command() {
    debug "Exporting database to: $exportdbparam"
    ddev export-db -f "$exportdbparam"
}

# Internal function for database import
_execute_import_command() {
    debug "Importing database from: $importdbparam"
    
    # Validate import file with context
    if ! check_file_exists "$importdbparam" "database import"; then
        return 1
    fi
    
    # Check file size and format
    if [[ ! -s "$importdbparam" ]]; then
        handle_error "Import file is empty: $importdbparam" "database import"
        return 1
    fi
    
    # Execute import with error handling
    if ! ddev import-db -f "$importdbparam"; then
        handle_error "Database import failed" "database import"
        info "Please check:"
        info "  - File format (SQL, compressed SQL, etc.)"
        info "  - Database connectivity"
        info "  - Available disk space"
        return 1
    fi
    
    info "Database import completed successfully"
}

# Internal functions for project operations
_execute_start_command() {
    debug "Starting project..."
    
    # Invalidate cache before starting
    local project_name
    if project_name=$(get_ddev_project_name 2>/dev/null); then
        unset "CONTAINER_STATUS_CACHE[$project_name]"
        debug "Invalidated cache for project: $project_name"
    fi
    
    ddev start
    ddev describe
    
    # Cache running state after successful start
    [[ -n "$project_name" ]] && cache_container_status "$project_name" "running"
}

_execute_stop_command() {
    debug "Stopping project..."
    
    # Invalidate cache before stopping
    local project_name
    if project_name=$(get_ddev_project_name 2>/dev/null); then
        unset "CONTAINER_STATUS_CACHE[$project_name]"
        debug "Invalidated cache for project: $project_name"
    fi
    
    ddev stop
    
    # Cache stopped state
    [[ -n "$project_name" ]] && cache_container_status "$project_name" "stopped"
}

_execute_restart_command() {
    debug "Restarting project..."
    
    # Invalidate cache before restarting
    local project_name
    if project_name=$(get_ddev_project_name 2>/dev/null); then
        unset "CONTAINER_STATUS_CACHE[$project_name]"
        debug "Invalidated cache for project: $project_name"
    fi
    
    ddev restart
    ddev describe
    
    # Cache running state after successful restart
    [[ -n "$project_name" ]] && cache_container_status "$project_name" "running"
}

_execute_status_command() {
    debug "Showing project status..."
    ddev describe
}

# Internal functions for direct command execution
_execute_ssh_command() {
    debug "Opening SSH connection..."
    ddev ssh
}

_execute_sequelace_command() {
    debug "Starting Sequel Ace..."
    ddev sequelace
}

_execute_launch_command() {
    if [[ -n "$launchparam" ]]; then
        debug "Opening specific URL: $launchparam"
        ddev launch "$launchparam"
    else
        debug "Opening default project URL..."
        ddev launch
    fi
}

# Internal functions for cache and testing operations
_execute_delete_cache_command() {
    debug "Deleting cache files..."
    ddev exec rm -rf var/cache/dev*
    ddev exec rm -rf var/cache/prod*
}

_execute_test_command() {
    debug "Running tests: ${testparam-}"
    ddev exec php bin/phpunit "${testparam-}"
}

# Start execution
main "$@"
